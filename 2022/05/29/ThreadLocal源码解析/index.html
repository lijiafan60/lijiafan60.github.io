<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="lijiafan"><meta name="keywords" content=""><meta name="description" content="基本使用和基础概念ThreadLocal有什么用简单来说，ThreadLocal可以给线程保存变量，实现线程间隔离。 简单使用ThreadLocal1234567891011121314151617181920212223242526272829public class ThreadLocalTest &amp;#123;    private static final ThreadLocal&lt;St"><meta property="og:type" content="article"><meta property="og:title" content="ThreadLocal源码解析"><meta property="og:url" content="http://example.com/2022/05/29/ThreadLocal%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.html"><meta property="og:site_name" content="扬帆社"><meta property="og:description" content="基本使用和基础概念ThreadLocal有什么用简单来说，ThreadLocal可以给线程保存变量，实现线程间隔离。 简单使用ThreadLocal1234567891011121314151617181920212223242526272829public class ThreadLocalTest &amp;#123;    private static final ThreadLocal&lt;St"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-05-29T07:32:55.728Z"><meta property="article:modified_time" content="2022-06-01T06:10:12.674Z"><meta property="article:author" content="lijiafan"><meta property="article:tag" content="Java多线程"><meta property="article:tag" content="ThreadLocal"><meta name="twitter:card" content="summary_large_image"><title>ThreadLocal源码解析 - 扬帆社</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"example.com",root:"/",version:"1.8.14",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.1.0"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>扬帆社</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(/img/homebg.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="ThreadLocal源码解析"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-05-29 15:32" pubdate>2022年5月29日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 17k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 141 分钟</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">ThreadLocal源码解析</h1><div class="markdown-body"><h1 id="基本使用和基础概念"><a href="#基本使用和基础概念" class="headerlink" title="基本使用和基础概念"></a>基本使用和基础概念</h1><h2 id="ThreadLocal有什么用"><a href="#ThreadLocal有什么用" class="headerlink" title="ThreadLocal有什么用"></a>ThreadLocal有什么用</h2><p>简单来说，ThreadLocal可以给线程保存变量，实现线程间隔离。</p><h2 id="简单使用ThreadLocal"><a href="#简单使用ThreadLocal" class="headerlink" title="简单使用ThreadLocal"></a>简单使用ThreadLocal</h2><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalTest</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;String&gt; threadLocal = ThreadLocal.withInitial(()-&gt;<span class="hljs-string">&quot;AAA&quot;</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                Thread.currentThread().setName(j + <span class="hljs-string">&quot;号线程&quot;</span>);<br><br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;的ThreadLocalMap : \n&quot;</span> +<br>                        threadLocal.hashCode() + <span class="hljs-string">&quot; : &quot;</span> + threadLocal.get() );<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br><br>                threadLocal.set(<span class="hljs-string">&quot;ABC&quot;</span> + j);<br><br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;的ThreadLocalMap : \n&quot;</span> +<br>                        threadLocal.hashCode() + <span class="hljs-string">&quot; : &quot;</span> + threadLocal.get() );<br>                threadLocal.remove();<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先定义了一个保存String类型变量的ThreadLocal，并且初始化为AAA。开启五个线程分别进行get、set，看看效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span>号线程的ThreadLocalMap : <br><span class="hljs-number">1288405787</span> : AAA<br><span class="hljs-number">0</span>号线程的ThreadLocalMap : <br><span class="hljs-number">1288405787</span> : ABC0<br><span class="hljs-number">1</span>号线程的ThreadLocalMap : <br><span class="hljs-number">1288405787</span> : AAA<br><span class="hljs-number">1</span>号线程的ThreadLocalMap : <br><span class="hljs-number">1288405787</span> : ABC1<br><span class="hljs-number">2</span>号线程的ThreadLocalMap : <br><span class="hljs-number">1288405787</span> : AAA<br><span class="hljs-number">2</span>号线程的ThreadLocalMap : <br><span class="hljs-number">1288405787</span> : ABC2<br><span class="hljs-number">3</span>号线程的ThreadLocalMap : <br><span class="hljs-number">1288405787</span> : AAA<br><span class="hljs-number">3</span>号线程的ThreadLocalMap : <br><span class="hljs-number">1288405787</span> : ABC3<br><span class="hljs-number">4</span>号线程的ThreadLocalMap : <br><span class="hljs-number">1288405787</span> : AAA<br><span class="hljs-number">4</span>号线程的ThreadLocalMap : <br><span class="hljs-number">1288405787</span> : ABC4<br></code></pre></td></tr></table></figure><p>可以看到前面的线程修改了ThreadLocal的值后，后面的线程一开始取到的还是最开始初始化的AAA，而不是前面线程修改后的值。也就是说ThreadLocal可以实现线程间隔离，<strong>即不同的线程对同一个ThreadLocal的操作是相互独立的。</strong></p><h2 id="ThreadLocal如何实现线程隔离"><a href="#ThreadLocal如何实现线程隔离" class="headerlink" title="ThreadLocal如何实现线程隔离"></a>ThreadLocal如何实现线程隔离</h2><h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><p>Thread类中有一个ThreadLocalMap字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    ......<br><br>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <br>	<span class="hljs-comment">//这个先不用管</span><br>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">inheritableThreadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>这个ThreadLocalMap又是啥呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocal</span>&lt;T&gt; &#123;<br>	<br>	......<br>	<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalMap</span> &#123;<br><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>            Object value;<br><br>            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>                <span class="hljs-built_in">super</span>(k);<br>                value = v;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br><br>        <span class="hljs-keyword">private</span> Entry[] table;<br><br>        ......<br>    &#125;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>ThreadLocalMap中有一个Entry数组，Entry是ThreadLocal的<strong>弱引用</strong>，Entry内还有一个Object。这个ThreadLocalMap和HashMap很类似，可以简单理解为：ThreadLocal的弱引用为Key，Object为Value。这样可以实现 ThreadLocal 和 Object 的一一对应。</p><p>看到这里，你一定会有诸多疑惑：</p><ol><li>为什么是操作ThreadLocal而不是直接操作Thread呢?</li><li>不同线程都操作同一个ThreadLocal怎么就能实现线程间隔离的效果呢？</li><li>为什么这个ThreadLocalMap要定义在ThreadLocal类的内部呢，为什么不定义在Thread类的内部呢？</li><li>……</li></ol><p>不要着急，我们接着往下看，打开ThreadLocal的源码，可以看到里面的get，set等方法，让我们看看它是怎么实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocal</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">threadLocalHashCode</span> <span class="hljs-operator">=</span> nextHashCode();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">nextHashCode</span> <span class="hljs-operator">=</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">HASH_INCREMENT</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x61c88647</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextHashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);<br>    &#125;<br><br>    ......<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>        ......<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>        ......<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>        ......<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> getMap(Thread.currentThread());<br>        <span class="hljs-keyword">if</span> (m != <span class="hljs-literal">null</span>)<br>            m.remove(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>        <span class="hljs-keyword">return</span> t.threadLocals;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>ThreadLocal在每次进行get、set等操作的时候，都会先获取到当前的线程，然后获取到线程内的ThreadLocalMap，而这个ThreadLocalMap里面存储的就是ThreadLocal和Object的映射，通过ThreadLocal获取对应的Object，因为ThreadLocalMap在每个Thread的内部，每个线程内的ThreadLocalMap都是不一样的，这样就达到了线程隔离的效果。</p><p>也就是说，<strong>在实际使用过程中，调用ThreadLocal对象的get、set方法时，会先去找到当前的线程内的ThreadLocalMap，再去进行相应的操作。这样ThreadLocal就能实现给线程保存变量，达到线程间隔离的效果</strong></p><p><strong>ThreadLocal本身是作为一个key来让线程从ThreadLocalMap获取value</strong>。</p><h1 id="源码详解"><a href="#源码详解" class="headerlink" title="源码详解"></a>源码详解</h1><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><h3 id="ThreadLocal哈希值的计算"><a href="#ThreadLocal哈希值的计算" class="headerlink" title="ThreadLocal哈希值的计算"></a>ThreadLocal哈希值的计算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocal</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">threadLocalHashCode</span> <span class="hljs-operator">=</span> nextHashCode();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">nextHashCode</span> <span class="hljs-operator">=</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">HASH_INCREMENT</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x61c88647</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextHashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>threadLocalHashCode被声明为final，说明是个常量，每个ThreadLocal对象生成的时候，它们的threadLocalHashCode就不会再变了。</li><li>threadLocalHashCode通过nextHashCode()方法生成，nextHashCode()方法通过将nextHashCode变量 + HASH_INCREMENT 得到新的hash值（这里方法名和字段名一样，不要搞混）</li><li>nextHashCode变量被声明为static，说明是所有ThreadLocal对象共用的，也就是说会有并发问题，所以这里设计成了AtomicInteger原子类，它的getAndAdd方法是原子性的。</li></ul><h3 id="魔数0x61c88647"><a href="#魔数0x61c88647" class="headerlink" title="魔数0x61c88647"></a>魔数0x61c88647</h3><p>思考一个问题：每次+0x61c88647 这种生成hash值的方法有什么好处呢？</p><p>这个值很特殊，它是<strong>斐波那契数</strong>也叫<strong>黄金分割数</strong>。hash增量为这个数字，带来的好处就是hash分布非常均匀。</p><p>引用别人的一组数据：</p><blockquote><p>(take 16 (magic-hash 16))<br>(0 7 14 5 12 3 10 1 8 15 6 13 4 11 2 9)</p><p>(take 32 (magic-hash 32))<br>(0 7 14 21 28 3 10 17 24 31 6 13 20 27 2 9 16 23 30 5 12 19 26 1 8 15 22 29 4 11 18 25)</p><p>(take 64 (magic-hash 64))<br>(0 7 14 21 28 35 42 49 56 63 6 13 20 27 34 41 48 55 62 5 12 19 26 33 40 47 54 61 4 11 18 25 32 39 46 53 60 3 10 17 24 31 38 45 52 59 2 9 16 23 30 37 44 51 58 1 8 15 22 29 36 43 50 57)</p></blockquote><p>确实是非常均匀！相关原理这里就不在深究了，想深入学习的可以查阅其他相关的资料。</p><h3 id="ThreadLocalMap的哈希算法"><a href="#ThreadLocalMap的哈希算法" class="headerlink" title="ThreadLocalMap的哈希算法"></a>ThreadLocalMap的哈希算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>ThreadLocalMap通过 <strong>hash值 &amp; (len-1)</strong> 来计算对应的位置，因为len的值是 2的n次方，所以hash&amp;(len-1)相当于对hash%len。（不理解的可以在草稿纸上手算算，就懂了）</p><h2 id="ThreadLocalMap-1"><a href="#ThreadLocalMap-1" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><h3 id="基本数据结构Entry"><a href="#基本数据结构Entry" class="headerlink" title="基本数据结构Entry"></a>基本数据结构Entry</h3><p>ThreadLocalMap内部存储的是Entry数组，每个Entry是ThreadLocal<strong>弱引用</strong>和Object的映射，和HashMap很类似。</p><p><strong>当发生GC的时候，如果一个对象只存在弱引用，那么它会被清理掉。</strong></p><p>所以Entry会存在引用为null，但是value还在的情况，但由于引用为null，所以这个value实际上永远都不会被访问到了，这就引发了内存泄漏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>    <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>    Object value;<br><br>    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>        <span class="hljs-built_in">super</span>(k);<br>        value = v;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> Entry[] table;<br></code></pre></td></tr></table></figure><h3 id="nextIndex与preIndex"><a href="#nextIndex与preIndex" class="headerlink" title="nextIndex与preIndex"></a>nextIndex与preIndex</h3><p>获取下一个位置和上一个位置的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> len)</span> &#123;<br>	<span class="hljs-keyword">return</span> ((i + <span class="hljs-number">1</span> &lt; len) ? i + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">prevIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> len)</span> &#123;<br>	<span class="hljs-keyword">return</span> ((i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) ? i - <span class="hljs-number">1</span> : len - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="初始容量"><a href="#初始容量" class="headerlink" title="初始容量"></a>初始容量</h3><p>ThreadLocalMap的初始容量为16</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br></code></pre></td></tr></table></figure><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><ul><li>当剩余容量不足1&#x2F;3时，会触发扩容</li><li>每次扩容都将当前容量*2，保证容量一直都是2的n次方</li><li>扩容后要将table（即Entry数组）内的元素rehash到正确的位置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//The number of entries in the table.</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//The next size value at which to resize.</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> threshold; <span class="hljs-comment">// Default to 0</span><br><br><span class="hljs-comment">// Set the resize threshold to maintain at worst a 2/3 load factor.</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setThreshold</span><span class="hljs-params">(<span class="hljs-type">int</span> len)</span> &#123;<br>    threshold = len * <span class="hljs-number">2</span> / <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">()</span> &#123;<br>    Entry[] oldTab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldLen</span> <span class="hljs-operator">=</span> oldTab.length;<br>    <span class="hljs-comment">//新容量为就容量*2</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">newLen</span> <span class="hljs-operator">=</span> oldLen * <span class="hljs-number">2</span>;<br>    Entry[] newTab = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[newLen];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldLen; ++j) &#123;<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> oldTab[j];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            ThreadLocal&lt;?&gt; k = e.get();<br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//k == null 说明引用的ThreadLocal被GC了</span><br>                <span class="hljs-comment">//防止内存泄漏</span><br>                e.value = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Help the GC</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> k.threadLocalHashCode &amp; (newLen - <span class="hljs-number">1</span>);<br>                <span class="hljs-comment">//如果发生hash冲突，就放到h后面第一个空的位置(为什么这么做后面再分析)</span><br>                <span class="hljs-keyword">while</span> (newTab[h] != <span class="hljs-literal">null</span>)<br>                    h = nextIndex(h, newLen);<br>                newTab[h] = e;<br>                count++;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    setThreshold(newLen);<br>    size = count;<br>    table = newTab;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="发生Hash冲突怎么办"><a href="#发生Hash冲突怎么办" class="headerlink" title="发生Hash冲突怎么办"></a>发生Hash冲突怎么办</h3><p>与HashMap不同的是，ThreadLocalMap在发生hash冲突的时候，并没有将entry升级为链，而是采用线性探测法：向后找到第一个能放的位置放。</p><p><strong>因为ThreadLocal采用的hash方式，会使得分布非常均匀</strong>，这样线性探测没多久就能找到空的位置。</p><h3 id="ThreadLocalMap-set"><a href="#ThreadLocalMap-set" class="headerlink" title="ThreadLocalMap.set()"></a>ThreadLocalMap.set()</h3><p>当向ThreadLocalMap中set数据的时候，首先会获取到Key对应的位置i。</p><ul><li>i位置为空<ul><li>退出for循环</li></ul></li><li>i位置不为空，则向后探测（i &#x3D; nextIndex(i, len)）<ul><li>i位置为空，退出for循环</li><li>找到一个Entry的key 等于 要set的key，更新value，<strong>return</strong></li><li>找到一个Key为null，说明该key已经过期（引用的ThreadLocal被清理了），执行replaceStaleEntry，<strong>return</strong></li></ul></li></ul><p>当遇到i位置为空，退出for循环后，会执行**tab[i] &#x3D; new Entry(key, value)**，封装一个Entry放进空的位置。</p><p>然后进行启发式清理（cleanSomeSlots），如果启发式清理没清理掉东西，并且sz &gt;&#x3D; threshold，就会执行rehash()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;<br>    <br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>         e != <span class="hljs-literal">null</span>;<br>         e = tab[i = nextIndex(i, len)]) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br><br>        <span class="hljs-keyword">if</span> (k == key) &#123;<br>            e.value = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>            replaceStaleEntry(key, value, i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    tab[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> ++size;<br>    <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>        rehash();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="replaceStaleEntry"><a href="#replaceStaleEntry" class="headerlink" title="replaceStaleEntry"></a>replaceStaleEntry</h4><p>这个函数是在Key&#x3D;&#x3D;null的时候才进入的，也就是说执行这个函数的时候，一定是有一些key失效的，那么在set值的时候，也要进行垃圾清理，在进行垃圾检测的时候，并不是检测所有的Entry，而是检测staleSlot位置所在的那一段非空Entry中是不是有过期key。</p><p>先解释下这个函数里的一些变量的含义：</p><p>​	staleSlot：该位置的key是过期的，同时也是新Entry要放的位置</p><p>​	slotToExpunge：垃圾清理开始的位置</p><p>​	<strong>注意：staleSlot位置放了新Entry之后就不是过期的了，也就是说如果最后slotToExpunge &#x3D;&#x3D; staleSlot，就不需要进行垃圾清理。</strong></p><p>文字版执行流程（也可以直接看源码，上面也写了注释）：</p><ul><li><p>首先从staleSlot位置向前探测，找到staleSlot左侧<strong>连续的非空Entry</strong>中<strong>最左边</strong>的过期key的位置，标记为slotToExpunge。</p></li><li><p>然后从staleSlot位置向后探测，找后面的<strong>连续的非空Entry</strong>中是否有k 等于 key</p><ul><li>如果相等的话，就和staleSlote位置的Entry交换，并且进行垃圾清理，<strong>return</strong>。</li><li>如果有位置k是过期的，并且staleSlot左边没有过期key（slotToExpunge &#x3D;&#x3D; staleSlot），就将slotToExpunge设为当前的位置</li></ul></li><li><p>接着将staleSlot位置的value清空，放入新的Entry（tab[staleSlot] &#x3D; new Entry(key, value)）（如果能走到这一步，说明staleSlot位置右边的Entry中没有k和key相等）</p></li><li><p>最后判断slotToExpunge如果不等于staleSlot，说明存在一些key失效，就需要进行垃圾清理（启发式清理+探测式清理），防止内存泄漏。</p></li></ul><p><strong>注：之所以要向后找，是因为在set时如果发生hash冲突，会将Entry放在右边第一个空的位置，所以需要向后探测，看看这个key是不是已经放过了，只不过因为hash冲突，放在了后面。同理，在get的时候，如果hashcode&amp;（len-1）位置不是对应的key，也要向后找。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">replaceStaleEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value,</span><br><span class="hljs-params">                               <span class="hljs-type">int</span> staleSlot)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    Entry e;<br>	<span class="hljs-comment">//从staleSlot位置向前探测，找到staleSlot左侧连续的非空Entry中最左边的过期key的位置，标记为slotToExpunge。</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">slotToExpunge</span> <span class="hljs-operator">=</span> staleSlot;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> prevIndex(staleSlot, len);<br>         (e = tab[i]) != <span class="hljs-literal">null</span>;<br>         i = prevIndex(i, len))<br>        <span class="hljs-keyword">if</span> (e.get() == <span class="hljs-literal">null</span>)<br>            slotToExpunge = i;<br>	<span class="hljs-comment">//遍历staleSlote后面的非空Entry</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nextIndex(staleSlot, len);<br>         (e = tab[i]) != <span class="hljs-literal">null</span>;<br>         i = nextIndex(i, len)) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br><br>        <span class="hljs-comment">//如果找到key，就要和staleSlote位置的Entry交换</span><br>        <span class="hljs-keyword">if</span> (k == key) &#123;<br>            e.value = value;<br><br>            tab[i] = tab[staleSlot];<br>            tab[staleSlot] = e;<br>            <span class="hljs-comment">//staleSlot位置的Key不再是过期的了，所以slotToExpunge如果等于staleSlot，就要更新成i</span><br>            <span class="hljs-keyword">if</span> (slotToExpunge == staleSlot)<br>                slotToExpunge = i;<br>            <span class="hljs-comment">//垃圾清理</span><br>            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>		<span class="hljs-comment">//更新slotToExpunge</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span> &amp;&amp; slotToExpunge == staleSlot)<br>            slotToExpunge = i;<br>    &#125;<br><br>    <span class="hljs-comment">// staleSlot位置放入新的Entry</span><br>    tab[staleSlot].value = <span class="hljs-literal">null</span>;<br>    tab[staleSlot] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);<br><br>    <span class="hljs-comment">// 如果slotToExpunge == staleSlot 说明没有需要清理的过期key，不需要进行垃圾清理。</span><br>    <span class="hljs-keyword">if</span> (slotToExpunge != staleSlot)<br>        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="过期Key的清理"><a href="#过期Key的清理" class="headerlink" title="过期Key的清理"></a>过期Key的清理</h4><h5 id="探测式清理（expungeStaleEntry）"><a href="#探测式清理（expungeStaleEntry）" class="headerlink" title="探测式清理（expungeStaleEntry）"></a>探测式清理（expungeStaleEntry）</h5><p>探测式清理主要做两个工作：</p><ol><li>清理staleSlot所在的那一段<strong>连续的不为null的Entry</strong>中key过期的Entry</li><li>因为清理会空出来一些位置，所以之前set的时候因为hash冲突，会有些key并不在hash &amp; (len-1) 的位置上，所以需要重新计算位置。这样做的目的是尽可能的让key的位置接近hash &amp; (len-1)，在get，set的时候效率会更高一些。</li></ol><p>expungeStaleEntry函数返回的是staleStole右边第一个Entry为null的位置，这个值在启发式清理里会用到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">expungeStaleEntry</span><span class="hljs-params">(<span class="hljs-type">int</span> staleSlot)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br><br>    <span class="hljs-comment">// 清空staleSlot位置的entry</span><br>    tab[staleSlot].value = <span class="hljs-literal">null</span>;<br>    tab[staleSlot] = <span class="hljs-literal">null</span>;<br>    size--;<br><br>    <span class="hljs-comment">// 当遇到key为null时rehash</span><br>    Entry e;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = nextIndex(staleSlot, len);<br>         (e = tab[i]) != <span class="hljs-literal">null</span>;<br>         i = nextIndex(i, len)) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>            e.value = <span class="hljs-literal">null</span>;<br>            tab[i] = <span class="hljs-literal">null</span>;<br>            size--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> k.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (h != i) &#123;<br>                tab[i] = <span class="hljs-literal">null</span>;<br>                <span class="hljs-comment">//找到离h最近的位置放，最坏的情况是仍然放在i位置</span><br>                <span class="hljs-keyword">while</span> (tab[h] != <span class="hljs-literal">null</span>)<br>                    h = nextIndex(h, len);<br>                tab[h] = e;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//这时候tab[i] = null</span><br>    <span class="hljs-keyword">return</span> i;<br>&#125;	<br></code></pre></td></tr></table></figure><h5 id="启发式清理（cleanSomeSlots）"><a href="#启发式清理（cleanSomeSlots）" class="headerlink" title="启发式清理（cleanSomeSlots）"></a>启发式清理（cleanSomeSlots）</h5><p>启发式清理就是从i位置开始向后遍历log(n)次，如果遇到过期的key，就进行探测式清理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cleanSomeSlots</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-keyword">do</span> &#123;<br>        i = nextIndex(i, len);<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == <span class="hljs-literal">null</span>) &#123;<br>            n = len;<br>            removed = <span class="hljs-literal">true</span>;<br>            i = expungeStaleEntry(i);<br>        &#125;<br>        <span class="hljs-comment">//n&gt;&gt;&gt;=1 每次会将n右移一位，一共会右移logn次</span><br>    &#125; <span class="hljs-keyword">while</span> ( (n &gt;&gt;&gt;= <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> removed;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：探测式清理和启发式清理都不能保证完全清理整个table中的所有过期key，只能清理局部的过期key</strong></p><h4 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h4><p>rehash会先对table（Entry数组）进行一次全面的垃圾清理（expungeStaleEntries）,然后如果size &gt;&#x3D; threshold - threshold &#x2F; 4则进行扩容。</p><p>因为threshold&#x3D;len * 2&#x2F;3,所以相当于size &gt;&#x3D; len * 1&#x2F;2。</p><p>至于为什么是 size &gt;&#x3D; threshold * 3&#x2F;4 官方是这么解释的：</p><blockquote><p>Use lower threshold for doubling to avoid hysteresis</p><p>使用较低的阈值来避免滞后。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rehash</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//进行全面的垃圾清理</span><br>    expungeStaleEntries();<br>    <span class="hljs-comment">//size &gt;= threshold * 3/4 = len * 1/2</span><br>    <span class="hljs-keyword">if</span> (size &gt;= threshold - threshold / <span class="hljs-number">4</span>)<br>        resize();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">expungeStaleEntries</span><span class="hljs-params">()</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; len; j++) &#123;<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[j];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == <span class="hljs-literal">null</span>)<br>            expungeStaleEntry(j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ThreadLocalMap-getEntry"><a href="#ThreadLocalMap-getEntry" class="headerlink" title="ThreadLocalMap.getEntry()"></a>ThreadLocalMap.getEntry()</h3><p>getEntry方法返回key对应的Entry</p><p>如果i位置没找到对应的key，就向后找，如果遇到失效key，就执行垃圾清理。最后如果没找到就返回null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> table[i];<br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == key)<br>        <span class="hljs-keyword">return</span> e;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">//e == null || e.get() != key</span><br>        <span class="hljs-keyword">return</span> getEntryAfterMiss(key, i, e);<br>&#125;<br><br><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntryAfterMiss</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, <span class="hljs-type">int</span> i, Entry e)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br><br>    <span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span>) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-keyword">if</span> (k == key)<br>            <span class="hljs-keyword">return</span> e;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>)<br>            expungeStaleEntry(i);<br>        <span class="hljs-keyword">else</span><br>            i = nextIndex(i, len);<br>        e = tab[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ThreadLocalMap-remove"><a href="#ThreadLocalMap-remove" class="headerlink" title="ThreadLocalMap.remove()"></a>ThreadLocalMap.remove()</h3><p>删除某个key对应的entry</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>         e != <span class="hljs-literal">null</span>;<br>         e = tab[i = nextIndex(i, len)]) &#123;<br>        <span class="hljs-keyword">if</span> (e.get() == key) &#123;<br>            <span class="hljs-comment">//将e的引用设为null</span><br>            e.clear();<br>            <span class="hljs-comment">//垃圾清理的时候会将table[i]清理掉</span><br>            expungeStaleEntry(i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ThreadLocal-set"><a href="#ThreadLocal-set" class="headerlink" title="ThreadLocal.set()"></a>ThreadLocal.set()</h2><p>取到当前线程的ThreadLocalMap，调用ThreadLocalMap.set()方法插入值，该方法前面已经分析过了，这里就不再赘述了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>    	map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>    	createMap(t, value);<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>    t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ThreadLocal-get"><a href="#ThreadLocal-get" class="headerlink" title="ThreadLocal.get()"></a>ThreadLocal.get()</h2><p>取到当前线程的ThreadLocalMap，再调用ThreadLocalMap.getEntry()方法得到Entry。如果得到的是map为nul或者e为null时，就调用ThreadLocal.setInitialValue()方法，如果为这个ThreadLocal设置过初始值的话，就会设置value为初始值，并返回。</p><p>ThreadLocal.setInitialValue() 和 ThreadLocal.set() 基本一样，这里也就不再赘述了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//找到当前的线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">//获取ThreadLocalMap</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//map不为null,则获取对应的Entry </span><br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//返回该Entry里的Object</span><br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//当map为null 或者 e为null时,需要执行这一步 </span><br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br><br><span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-comment">//如果map不为null，就将initialVal设置成对应的Object，插入map。</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-comment">//如果map为null，为t线程创建ThreadLocalMap,并初始化</span><br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><span class="hljs-comment">//如果不指定的话，初始值就是null</span><br><span class="hljs-keyword">protected</span> T <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="为ThreadLocal设置初始值"><a href="#为ThreadLocal设置初始值" class="headerlink" title="为ThreadLocal设置初始值"></a>为ThreadLocal设置初始值</h2><p>可以通过 <strong>ThreadLocal.withInitial(…)</strong> 来为ThreadLocal设置初始值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; ThreadLocal&lt;S&gt; <span class="hljs-title function_">withInitial</span><span class="hljs-params">(Supplier&lt;? extends S&gt; supplier)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuppliedThreadLocal</span>&lt;&gt;(supplier);<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SuppliedThreadLocal</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadLocal</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Supplier&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>&gt; supplier;<br><br>    SuppliedThreadLocal(Supplier&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>&gt; supplier) &#123;<br>        <span class="hljs-built_in">this</span>.supplier = Objects.requireNonNull(supplier);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> T <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> supplier.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到SuppliedThreadLocal继承了ThreadLocal，实现了它的initialValue方法，return的是supplier.get()</p><p>那么这个Supplier是啥呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Supplier</span>&lt;T&gt; &#123;<br>    T <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实就是一个函数式接口，实现它的get方法返回你要的东西，也就是我们需要的初始值。</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="ThreadLocal中的AtomicInteger为什么是private"><a href="#ThreadLocal中的AtomicInteger为什么是private" class="headerlink" title="ThreadLocal中的AtomicInteger为什么是private"></a>ThreadLocal中的AtomicInteger为什么是private</h2><p>如果不是private的话，每新建一个ThreadLocal对象都会生成新的AtomicInteger，这样算出的hashcode就不对了。</p><h2 id="ThreadLocalMap为什么设计为ThreadLocal的内部类"><a href="#ThreadLocalMap为什么设计为ThreadLocal的内部类" class="headerlink" title="ThreadLocalMap为什么设计为ThreadLocal的内部类"></a>ThreadLocalMap为什么设计为ThreadLocal的内部类</h2><ul><li>ThreadLocalMap在Thread中默认为null</li><li>操作ThreadLocal的时候会检查线程中的ThreadLocalMap是否为null，如果为null就新建一个。</li><li>这样做的好处是可以实现ThreadLocalMap的按需加载，不会浪费资源。</li><li>如果设计在Thread内，那么在new Thread的时候就要创建出ThreadLocalMap，但如果用不到的话，就会浪费资源。</li></ul><h2 id="Entry为什么是弱引用WearReference"><a href="#Entry为什么是弱引用WearReference" class="headerlink" title="Entry为什么是弱引用WearReference"></a>Entry为什么是弱引用WearReference</h2><p>首先，弱引用增加了ThreadLocal的复杂度—-在get、set的时候都要判断key是否为null，还要考虑过期key的清理，还有可能造成内存泄露的问题。还需要考虑要用的value的key被GC了的情况，那么为什么要这么设计呢？</p><p>我认为：</p><ul><li><p>如果是强引用就会形成这么个引用链：Thread-&gt;ThreadLocalMap-&gt;Entry-&gt;[ThreadLocal,Value]，那么如果使用者用完不<strong>手动将Entry设为null</strong>（设为null的话GC的时候通过可达性分析是可以清理掉ThreadLocal的）的话，在使用ThreadLoal的线程全部结束前，ThreadLocal对象是一直存在的。</p></li><li><p>如果使用者粗心大意，没有在用完后将Entry设为null，那么可能会造成严重的内存泄漏（引用的ThreadLocal和value后面不再需要，白白占用内存空间），<strong>且只会比弱引用更严重</strong>，并且<strong>难以修复</strong>（因为都是强引用，GC的时候不会清理掉）</p></li><li><p>为了避免使用者的粗心，所以设计人员才将Entry设置为弱引用，在get、set、扩容等操作时，都会进行失效key的清理，虽然一定程度上增加了复杂度，损失了一点性能，但能很大程度上避免内存泄漏。</p></li><li><p>同时，在使用ThreadLocal的时候，我们一般也要在用完后进行**手动的remove()**，这样其实即使是弱引用，也不用担心会发生内存泄漏。</p></li><li><p>分析到这里我们也发现了：不管是弱引用还是强引用都要<strong>手动释放引用</strong>。</p><p>但如果使用者忘了，如果是弱引用的话，可以通过在get、set、扩容等方法中穿插清理失效key，这能在很大程度上减缓内存泄漏带来的影响。但如果是强引用的话，就没啥好的办法了（也许只能在jvm的堆快满了的时候进行full gc才会清理调它们），极端情况下，可能会对系统造成严重的影响。</p><p>但如果使用者有及时释放的好习惯的话，在get、set、扩容等方法中寻找到key&#x3D;&#x3D;null的情况就很少了，算下来其实也不会浪费多少性能。</p></li></ul><h2 id="ThreadLocal为什么需要定义成static"><a href="#ThreadLocal为什么需要定义成static" class="headerlink" title="ThreadLocal为什么需要定义成static"></a>ThreadLocal为什么需要定义成static</h2><p>ThreadLocal 类的目的是为每个线程单独维护一个变量的值，避免线程间对同一变量的竞争访问，适用于一个变量在每个线程中需要有自己独立的值的场合。</p><p>如果把 ThreadLocal 声明为非静态，则在含有 ThreadLocal 变量的的每个实例中都会产生一个新对象，这就起不到对应的效果了（通过一个ThreadLocal在不同的线程中获取不同的值）。</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>在访问不到的数据被回收之前，内存泄漏确实是存在的，但是在进行get、set、扩容等操作时，都会检查失效key的清理，一般在使用的时候，用完要手动remove，所以，内存泄漏完全没必要过于担心。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="用户信息保存"><a href="#用户信息保存" class="headerlink" title="用户信息保存"></a>用户信息保存</h2><p>这是我在面试阿里的时候遇到的面试题，题目大致是这样的：</p><p><strong>controller层在处理用户请求的时候，如果方法里面不写参数，怎么知道当前的用户是谁。</strong></p><p>解答：在前后端分离的项目中（现在绝大多数都是前后端分离），用户登录后，用户信息会保存在Session或者Token中。当我们需要用户信息的时候，拿Session来说，我们可以在接口参数中加上HttpServletRequest，调用 getSession方法获取信息，但是如果且每一个需要用户信息的接口都要加上这个参数，才能获取Session，这样实现就比较麻烦。</p><p>在实际的系统设计中，一般都会在拦截器中使用ThreadLocal，保存用户信息。那么当前线程在任何地方如果需要拿到用户信息都可以使用ThreadLocal的get()方法 。</p><h2 id="Spring-单例模式下的线程安全问题"><a href="#Spring-单例模式下的线程安全问题" class="headerlink" title="Spring 单例模式下的线程安全问题"></a>Spring 单例模式下的线程安全问题</h2><p>在Spring的Web项目中,Dao层一般都是单例，但spring的单例指的是在Bean容器中只有一个对象，它并不能保证线程安全。当多线程线程请求打上来的时候，因为负责数据库连接的Connection只有一个，如果每个请求线程都去连接数据库，就会造成线程不安全的问题。</p><p>Spring的解决方案就是采用ThreadLocal方法，当每个请求线程使用Connection的时候， 都会从ThreadLocal获取一次，如果为null，说明没有进行过数据库连接，连接后存入ThreadLocal中，如此一来，每一个请求线程都保存有一份自己的Connection。于是便解决了线程安全问题</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903648800014349#heading-5">为什么使用0x61c88647</a></p><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904146127044622">万字图文深度解析ThreadLocal</a></p><p><a target="_blank" rel="noopener" href="https://www.modb.pro/db/194154">为什么ThreadLocal容易导致内存泄漏？</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/489079713">一文读懂ThreadLocal</a></p></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Java多线程</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Java多线程</a> <a class="hover-with-bg" href="/tags/ThreadLocal/">ThreadLocal</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/2022/06/03/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">接口限流原理到实践</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2022/05/12/%E5%90%8C%E7%B1%BB%E5%9E%8Bbean%E6%97%A0%E6%B3%95%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%97%AE%E9%A2%98/"><span class="hidden-mobile">ClassCastException之同类型bean无法进行类型转换的问题</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/local-search.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script src="/js/boot.js"></script></body></html>