<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>双重检测锁为什么要加Volatile</title>
    <link href="/2022/06/09/%E5%8F%8C%E9%87%8D%E6%A3%80%E6%B5%8B%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8A%A0Volatile/"/>
    <url>/2022/06/09/%E5%8F%8C%E9%87%8D%E6%A3%80%E6%B5%8B%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8A%A0Volatile/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单例模式</tag>
      
      <tag>volatile</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring（面经）</title>
    <link href="/2022/06/08/spring%EF%BC%88%E9%9D%A2%E7%BB%8F%EF%BC%89/"/>
    <url>/2022/06/08/spring%EF%BC%88%E9%9D%A2%E7%BB%8F%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h1><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="Spring声明式事务原理？哪些场景事务会失效？-1"><a href="#Spring声明式事务原理？哪些场景事务会失效？-1" class="headerlink" title="Spring声明式事务原理？哪些场景事务会失效？ 1"></a>Spring声明式事务原理？哪些场景事务会失效？ <em>1</em></h2>]]></content>
    
    
    <categories>
      
      <category>面经整理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git使用指南</title>
    <link href="/2022/06/06/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2022/06/06/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="将本地项目上传到github"><a href="#将本地项目上传到github" class="headerlink" title="将本地项目上传到github"></a>将本地项目上传到github</h1><ol><li>github新建一个项目</li><li>在本地项目的根目录下打开gitbash</li><li>git初始化 <figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure></li><li>连接到远程仓库 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin 远程项目链接<br></code></pre></td></tr></table></figure></li><li>如果github上的远程项目有README.md这种本地没有的文件的话需要先pull合并一下 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull --rebase origin master<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBean创建流程分析</title>
    <link href="/2022/06/03/SpringBean%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <url>/2022/06/03/SpringBean%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>源码解析</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ReenteredLock源码解析</title>
    <link href="/2022/06/03/ReenteredLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/06/03/ReenteredLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Java多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java多线程</tag>
      
      <tag>JUC</tag>
      
      <tag>源码解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis实现接口限流</title>
    <link href="/2022/06/03/Redis%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81/"/>
    <url>/2022/06/03/Redis%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="接口限流的4中方案"><a href="#接口限流的4中方案" class="headerlink" title="接口限流的4中方案"></a>接口限流的4中方案</h1><h2 id="固定窗口计数器"><a href="#固定窗口计数器" class="headerlink" title="固定窗口计数器"></a>固定窗口计数器</h2><ul><li>将时间划分为多个窗口</li><li>在每个窗口内每有一次请求就将计数器加一</li><li>如果计数器超过了限制数量，则本窗口内所有的请求都被丢弃当时间到达下一个窗口时，计数器重置。</li><li>固定窗口计数器是最为简单的算法，但这个算法有时会让通过请求量允许为限制的两倍。考虑如下情况：限制 1 秒内最多通过 5 个请求，在第一个窗口的最后半秒内通过了 5 个请求，第二个窗口的前半秒内又通过了 5 个请求。这样看来就是在 1 秒内通过了 10 个请求。</li></ul><h2 id="滑动窗口计数器"><a href="#滑动窗口计数器" class="headerlink" title="滑动窗口计数器"></a>滑动窗口计数器</h2><ul><li>将时间划分为多个区间；</li><li>在每个区间内每有一次请求就将计数器加一维持一个时间窗口，占据多个区间；</li><li>每经过一个区间的时间，则抛弃最老的一个区间，并纳入最新的一个区间；</li><li>如果当前窗口内区间的请求计数总和超过了限制数量，则本窗口内所有的请求都被丢弃。</li><li>滑动窗口计数器是通过将窗口再细分，并且按照时间 “ 滑动 “，这种算法避免了固定窗口计数器带来的双倍突发请求，但时间区间的精度越高，算法所需的空间容量就越大。</li></ul><h2 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h2><ul><li>将每个请求视作 “ 水滴 “ 放入 “ 漏桶 “ 进行存储；</li><li>漏桶算法多使用队列实现，服务的请求会存到队列中，服务的提供方则按照固定的速率从队列中取出请求并执行，过多的请求则放在队列中排队或直接拒绝。</li><li>漏桶算法的缺陷也很明显，当短时间内有大量的突发请求时，即便此时服务器没有任何负载，每个请求也都得在队列中等待一段时间才能被响应。</li></ul><h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><ul><li>令牌以固定速率生成。</li><li>生成的令牌放入令牌桶中存放，如果令牌桶满了则多余的令牌会直接丢弃，当请求到达时，会尝试从令牌桶中取令牌，取到了令牌的请求可以执行。</li><li>如果桶空了，那么尝试取令牌的请求会被直接丢弃。</li><li>令牌桶算法既能够将所有的请求平均分布到时间区间内，又能接受服务器能够承受范围内的突发请求，因此是目前使用较为广泛的一种限流算法。</li></ul><h1 id="使用令牌桶方法实现接口限流"><a href="#使用令牌桶方法实现接口限流" class="headerlink" title="使用令牌桶方法实现接口限流"></a>使用令牌桶方法实现接口限流</h1>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis基础概念</title>
    <link href="/2022/06/02/Redis%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2022/06/02/Redis%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h1><p>redis是一款基于c语言开发的内存数据库，速度非常快，经常被用来做缓存</p><h1 id="Redis的基本数据类型"><a href="#Redis的基本数据类型" class="headerlink" title="Redis的基本数据类型"></a>Redis的基本数据类型</h1><h1 id="Redis应用场景"><a href="#Redis应用场景" class="headerlink" title="Redis应用场景"></a>Redis应用场景</h1><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><h1 id="文件事件处理器"><a href="#文件事件处理器" class="headerlink" title="文件事件处理器"></a>文件事件处理器</h1><h1 id="如何判断数据过期"><a href="#如何判断数据过期" class="headerlink" title="如何判断数据过期"></a>如何判断数据过期</h1><h1 id="过期键的删除策略"><a href="#过期键的删除策略" class="headerlink" title="过期键的删除策略"></a>过期键的删除策略</h1><h1 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h1><h1 id="缓存异常"><a href="#缓存异常" class="headerlink" title="缓存异常"></a>缓存异常</h1><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h2 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h2><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><h2 id="如何开启事务"><a href="#如何开启事务" class="headerlink" title="如何开启事务"></a>如何开启事务</h2><h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal源码解析</title>
    <link href="/2022/05/29/ThreadLocal%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/05/29/ThreadLocal%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="基本使用和基础概念"><a href="#基本使用和基础概念" class="headerlink" title="基本使用和基础概念"></a>基本使用和基础概念</h1><h2 id="ThreadLocal有什么用"><a href="#ThreadLocal有什么用" class="headerlink" title="ThreadLocal有什么用"></a>ThreadLocal有什么用</h2><p>简单来说，ThreadLocal可以给线程保存变量，实现线程间隔离。</p><h2 id="简单使用ThreadLocal"><a href="#简单使用ThreadLocal" class="headerlink" title="简单使用ThreadLocal"></a>简单使用ThreadLocal</h2><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalTest</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;String&gt; threadLocal = ThreadLocal.withInitial(()-&gt;<span class="hljs-string">&quot;AAA&quot;</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                Thread.currentThread().setName(j + <span class="hljs-string">&quot;号线程&quot;</span>);<br><br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;的ThreadLocalMap : \n&quot;</span> +<br>                        threadLocal.hashCode() + <span class="hljs-string">&quot; : &quot;</span> + threadLocal.get() );<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br><br>                threadLocal.set(<span class="hljs-string">&quot;ABC&quot;</span> + j);<br><br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;的ThreadLocalMap : \n&quot;</span> +<br>                        threadLocal.hashCode() + <span class="hljs-string">&quot; : &quot;</span> + threadLocal.get() );<br>                threadLocal.remove();<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先定义了一个保存String类型变量的ThreadLocal，并且初始化为AAA。开启五个线程分别进行get、set，看看效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span>号线程的ThreadLocalMap : <br><span class="hljs-number">1288405787</span> : AAA<br><span class="hljs-number">0</span>号线程的ThreadLocalMap : <br><span class="hljs-number">1288405787</span> : ABC0<br><span class="hljs-number">1</span>号线程的ThreadLocalMap : <br><span class="hljs-number">1288405787</span> : AAA<br><span class="hljs-number">1</span>号线程的ThreadLocalMap : <br><span class="hljs-number">1288405787</span> : ABC1<br><span class="hljs-number">2</span>号线程的ThreadLocalMap : <br><span class="hljs-number">1288405787</span> : AAA<br><span class="hljs-number">2</span>号线程的ThreadLocalMap : <br><span class="hljs-number">1288405787</span> : ABC2<br><span class="hljs-number">3</span>号线程的ThreadLocalMap : <br><span class="hljs-number">1288405787</span> : AAA<br><span class="hljs-number">3</span>号线程的ThreadLocalMap : <br><span class="hljs-number">1288405787</span> : ABC3<br><span class="hljs-number">4</span>号线程的ThreadLocalMap : <br><span class="hljs-number">1288405787</span> : AAA<br><span class="hljs-number">4</span>号线程的ThreadLocalMap : <br><span class="hljs-number">1288405787</span> : ABC4<br></code></pre></td></tr></table></figure><p>可以看到前面的线程修改了ThreadLocal的值后，后面的线程一开始取到的还是最开始初始化的AAA，而不是前面线程修改后的值。也就是说ThreadLocal可以实现线程间隔离，<strong>即不同的线程对同一个ThreadLocal的操作是相互独立的。</strong></p><h2 id="ThreadLocal如何实现线程隔离"><a href="#ThreadLocal如何实现线程隔离" class="headerlink" title="ThreadLocal如何实现线程隔离"></a>ThreadLocal如何实现线程隔离</h2><h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><p>Thread类中有一个ThreadLocalMap字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    ......<br><br>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <br><span class="hljs-comment">//这个先不用管</span><br>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">inheritableThreadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>这个ThreadLocalMap又是啥呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocal</span>&lt;T&gt; &#123;<br><br>......<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalMap</span> &#123;<br><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>            Object value;<br><br>            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>                <span class="hljs-built_in">super</span>(k);<br>                value = v;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br><br>        <span class="hljs-keyword">private</span> Entry[] table;<br><br>        ......<br>    &#125;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>ThreadLocalMap中有一个Entry数组，Entry是ThreadLocal的<strong>弱引用</strong>，Entry内还有一个Object。这个ThreadLocalMap和HashMap很类似，可以简单理解为：ThreadLocal的弱引用为Key，Object为Value。这样可以实现 ThreadLocal 和 Object 的一一对应。</p><p>看到这里，你一定会有诸多疑惑：</p><ol><li>为什么是操作ThreadLocal而不是直接操作Thread呢?</li><li>不同线程都操作同一个ThreadLocal怎么就能实现线程间隔离的效果呢？</li><li>为什么这个ThreadLocalMap要定义在ThreadLocal类的内部呢，为什么不定义在Thread类的内部呢？</li><li>……</li></ol><p>不要着急，我们接着往下看，打开ThreadLocal的源码，可以看到里面的get，set等方法，让我们看看它是怎么实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocal</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">threadLocalHashCode</span> <span class="hljs-operator">=</span> nextHashCode();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">nextHashCode</span> <span class="hljs-operator">=</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">HASH_INCREMENT</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x61c88647</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextHashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);<br>    &#125;<br><br>    ......<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>        ......<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>        ......<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>        ......<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> getMap(Thread.currentThread());<br>        <span class="hljs-keyword">if</span> (m != <span class="hljs-literal">null</span>)<br>            m.remove(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>        <span class="hljs-keyword">return</span> t.threadLocals;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>ThreadLocal在每次进行get、set等操作的时候，都会先获取到当前的线程，然后获取到线程内的ThreadLocalMap，而这个ThreadLocalMap里面存储的就是ThreadLocal和Object的映射，通过ThreadLocal获取对应的Object，因为ThreadLocalMap在每个Thread的内部，每个线程内的ThreadLocalMap都是不一样的，这样就达到了线程隔离的效果。</p><p>也就是说，<strong>在实际使用过程中，调用ThreadLocal对象的get、set方法时，会先去找到当前的线程内的ThreadLocalMap，再去进行相应的操作。这样ThreadLocal就能实现给线程保存变量，达到线程间隔离的效果</strong></p><p><strong>ThreadLocal本身是作为一个key来让线程从ThreadLocalMap获取value</strong>。 </p><h1 id="源码详解"><a href="#源码详解" class="headerlink" title="源码详解"></a>源码详解</h1><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><h3 id="ThreadLocal哈希值的计算"><a href="#ThreadLocal哈希值的计算" class="headerlink" title="ThreadLocal哈希值的计算"></a>ThreadLocal哈希值的计算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocal</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">threadLocalHashCode</span> <span class="hljs-operator">=</span> nextHashCode();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">nextHashCode</span> <span class="hljs-operator">=</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">HASH_INCREMENT</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x61c88647</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextHashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>threadLocalHashCode被声明为final，说明是个常量，每个ThreadLocal对象生成的时候，它们的threadLocalHashCode就不会再变了。</li><li>threadLocalHashCode通过nextHashCode()方法生成，nextHashCode()方法通过将nextHashCode变量 + HASH_INCREMENT 得到新的hash值（这里方法名和字段名一样，不要搞混）</li><li>nextHashCode变量被声明为static，说明是所有ThreadLocal对象共用的，也就是说会有并发问题，所以这里设计成了AtomicInteger原子类，它的getAndAdd方法是原子性的。</li></ul><h3 id="魔数0x61c88647"><a href="#魔数0x61c88647" class="headerlink" title="魔数0x61c88647"></a>魔数0x61c88647</h3><p>思考一个问题：每次+0x61c88647 这种生成hash值的方法有什么好处呢？</p><p>这个值很特殊，它是<strong>斐波那契数</strong>也叫<strong>黄金分割数</strong>。hash增量为这个数字，带来的好处就是hash分布非常均匀。</p><p>引用别人的一组数据：</p><blockquote><p>(take 16 (magic-hash 16))<br>(0 7 14 5 12 3 10 1 8 15 6 13 4 11 2 9)</p><p>(take 32 (magic-hash 32))<br>(0 7 14 21 28 3 10 17 24 31 6 13 20 27 2 9 16 23 30 5 12 19 26 1 8 15 22 29 4 11 18 25)</p><p>(take 64 (magic-hash 64))<br>(0 7 14 21 28 35 42 49 56 63 6 13 20 27 34 41 48 55 62 5 12 19 26 33 40 47 54 61 4 11 18 25 32 39 46 53 60 3 10 17 24 31 38 45 52 59 2 9 16 23 30 37 44 51 58 1 8 15 22 29 36 43 50 57)</p></blockquote><p>确实是非常均匀！相关原理这里就不在深究了，想深入学习的可以查阅其他相关的资料。</p><h3 id="ThreadLocalMap的哈希算法"><a href="#ThreadLocalMap的哈希算法" class="headerlink" title="ThreadLocalMap的哈希算法"></a>ThreadLocalMap的哈希算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>ThreadLocalMap通过 <strong>hash值 &amp; (len-1)</strong> 来计算对应的位置，因为len的值是 2的n次方，所以hash&amp;(len-1)相当于对hash%len。（不理解的可以在草稿纸上手算算，就懂了）</p><h2 id="ThreadLocalMap-1"><a href="#ThreadLocalMap-1" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><h3 id="基本数据结构Entry"><a href="#基本数据结构Entry" class="headerlink" title="基本数据结构Entry"></a>基本数据结构Entry</h3><p>ThreadLocalMap内部存储的是Entry数组，每个Entry是ThreadLocal<strong>弱引用</strong>和Object的映射，和HashMap很类似。</p><p><strong>当发生GC的时候，如果一个对象只存在弱引用，那么它会被清理掉。</strong></p><p>所以Entry会存在引用为null，但是value还在的情况，但由于引用为null，所以这个value实际上永远都不会被访问到了，这就引发了内存泄漏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>    <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>    Object value;<br><br>    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>        <span class="hljs-built_in">super</span>(k);<br>        value = v;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> Entry[] table;<br></code></pre></td></tr></table></figure><h3 id="nextIndex与preIndex"><a href="#nextIndex与preIndex" class="headerlink" title="nextIndex与preIndex"></a>nextIndex与preIndex</h3><p>获取下一个位置和上一个位置的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> len)</span> &#123;<br><span class="hljs-keyword">return</span> ((i + <span class="hljs-number">1</span> &lt; len) ? i + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">prevIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> len)</span> &#123;<br><span class="hljs-keyword">return</span> ((i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) ? i - <span class="hljs-number">1</span> : len - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="初始容量"><a href="#初始容量" class="headerlink" title="初始容量"></a>初始容量</h3><p>ThreadLocalMap的初始容量为16</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br></code></pre></td></tr></table></figure><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><ul><li>当剩余容量不足1&#x2F;3时，会触发扩容</li><li>每次扩容都将当前容量*2，保证容量一直都是2的n次方</li><li>扩容后要将table（即Entry数组）内的元素rehash到正确的位置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//The number of entries in the table.</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//The next size value at which to resize.</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> threshold; <span class="hljs-comment">// Default to 0</span><br><br><span class="hljs-comment">// Set the resize threshold to maintain at worst a 2/3 load factor.</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setThreshold</span><span class="hljs-params">(<span class="hljs-type">int</span> len)</span> &#123;<br>    threshold = len * <span class="hljs-number">2</span> / <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">()</span> &#123;<br>    Entry[] oldTab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldLen</span> <span class="hljs-operator">=</span> oldTab.length;<br>    <span class="hljs-comment">//新容量为就容量*2</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">newLen</span> <span class="hljs-operator">=</span> oldLen * <span class="hljs-number">2</span>;<br>    Entry[] newTab = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[newLen];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldLen; ++j) &#123;<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> oldTab[j];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            ThreadLocal&lt;?&gt; k = e.get();<br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//k == null 说明引用的ThreadLocal被GC了</span><br>                <span class="hljs-comment">//防止内存泄漏</span><br>                e.value = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Help the GC</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> k.threadLocalHashCode &amp; (newLen - <span class="hljs-number">1</span>);<br>                <span class="hljs-comment">//如果发生hash冲突，就放到h后面第一个空的位置(为什么这么做后面再分析)</span><br>                <span class="hljs-keyword">while</span> (newTab[h] != <span class="hljs-literal">null</span>)<br>                    h = nextIndex(h, newLen);<br>                newTab[h] = e;<br>                count++;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    setThreshold(newLen);<br>    size = count;<br>    table = newTab;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="发生Hash冲突怎么办"><a href="#发生Hash冲突怎么办" class="headerlink" title="发生Hash冲突怎么办"></a>发生Hash冲突怎么办</h3><p>与HashMap不同的是，ThreadLocalMap在发生hash冲突的时候，并没有将entry升级为链，而是采用线性探测法：向后找到第一个能放的位置放。</p><p><strong>因为ThreadLocal采用的hash方式，会使得分布非常均匀</strong>，这样线性探测没多久就能找到空的位置。</p><h3 id="ThreadLocalMap-set"><a href="#ThreadLocalMap-set" class="headerlink" title="ThreadLocalMap.set()"></a>ThreadLocalMap.set()</h3><p>当向ThreadLocalMap中set数据的时候，首先会获取到Key对应的位置i。</p><ul><li>i位置为空<ul><li>退出for循环</li></ul></li><li>i位置不为空，则向后探测（i &#x3D; nextIndex(i, len)）<ul><li>i位置为空，退出for循环</li><li>找到一个Entry的key 等于 要set的key，更新value，<strong>return</strong></li><li>找到一个Key为null，说明该key已经过期（引用的ThreadLocal被清理了），执行replaceStaleEntry，<strong>return</strong></li></ul></li></ul><p>当遇到i位置为空，退出for循环后，会执行**tab[i] &#x3D; new Entry(key, value)**，封装一个Entry放进空的位置。</p><p>然后进行启发式清理（cleanSomeSlots），如果启发式清理没清理掉东西，并且sz &gt;&#x3D; threshold，就会执行rehash()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;<br>    <br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>         e != <span class="hljs-literal">null</span>;<br>         e = tab[i = nextIndex(i, len)]) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br><br>        <span class="hljs-keyword">if</span> (k == key) &#123;<br>            e.value = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>            replaceStaleEntry(key, value, i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    tab[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> ++size;<br>    <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>        rehash();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="replaceStaleEntry"><a href="#replaceStaleEntry" class="headerlink" title="replaceStaleEntry"></a>replaceStaleEntry</h4><p>这个函数是在Key&#x3D;&#x3D;null的时候才进入的，也就是说执行这个函数的时候，一定是有一些key失效的，那么在set值的时候，也要进行垃圾清理，在进行垃圾检测的时候，并不是检测所有的Entry，而是检测staleSlot位置所在的那一段非空Entry中是不是有过期key。</p><p>先解释下这个函数里的一些变量的含义：</p><p>​staleSlot：该位置的key是过期的，同时也是新Entry要放的位置</p><p>​slotToExpunge：垃圾清理开始的位置</p><p>​<strong>注意：staleSlot位置放了新Entry之后就不是过期的了，也就是说如果最后slotToExpunge &#x3D;&#x3D; staleSlot，就不需要进行垃圾清理。</strong></p><p>文字版执行流程（也可以直接看源码，上面也写了注释）：</p><ul><li><p>首先从staleSlot位置向前探测，找到staleSlot左侧<strong>连续的非空Entry</strong>中<strong>最左边</strong>的过期key的位置，标记为slotToExpunge。</p></li><li><p>然后从staleSlot位置向后探测，找后面的<strong>连续的非空Entry</strong>中是否有k 等于 key</p><ul><li>如果相等的话，就和staleSlote位置的Entry交换，并且进行垃圾清理，<strong>return</strong>。</li><li>如果有位置k是过期的，并且staleSlot左边没有过期key（slotToExpunge &#x3D;&#x3D; staleSlot），就将slotToExpunge设为当前的位置</li></ul></li><li><p>接着将staleSlot位置的value清空，放入新的Entry（tab[staleSlot] &#x3D; new Entry(key, value)）（如果能走到这一步，说明staleSlot位置右边的Entry中没有k和key相等）</p></li><li><p>最后判断slotToExpunge如果不等于staleSlot，说明存在一些key失效，就需要进行垃圾清理（启发式清理+探测式清理），防止内存泄漏。</p></li></ul><p><strong>注：之所以要向后找，是因为在set时如果发生hash冲突，会将Entry放在右边第一个空的位置，所以需要向后探测，看看这个key是不是已经放过了，只不过因为hash冲突，放在了后面。同理，在get的时候，如果hashcode&amp;（len-1）位置不是对应的key，也要向后找。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">replaceStaleEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value,</span><br><span class="hljs-params">                               <span class="hljs-type">int</span> staleSlot)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    Entry e;<br><span class="hljs-comment">//从staleSlot位置向前探测，找到staleSlot左侧连续的非空Entry中最左边的过期key的位置，标记为slotToExpunge。</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">slotToExpunge</span> <span class="hljs-operator">=</span> staleSlot;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> prevIndex(staleSlot, len);<br>         (e = tab[i]) != <span class="hljs-literal">null</span>;<br>         i = prevIndex(i, len))<br>        <span class="hljs-keyword">if</span> (e.get() == <span class="hljs-literal">null</span>)<br>            slotToExpunge = i;<br><span class="hljs-comment">//遍历staleSlote后面的非空Entry</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nextIndex(staleSlot, len);<br>         (e = tab[i]) != <span class="hljs-literal">null</span>;<br>         i = nextIndex(i, len)) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br><br>        <span class="hljs-comment">//如果找到key，就要和staleSlote位置的Entry交换</span><br>        <span class="hljs-keyword">if</span> (k == key) &#123;<br>            e.value = value;<br><br>            tab[i] = tab[staleSlot];<br>            tab[staleSlot] = e;<br>            <span class="hljs-comment">//staleSlot位置的Key不再是过期的了，所以slotToExpunge如果等于staleSlot，就要更新成i</span><br>            <span class="hljs-keyword">if</span> (slotToExpunge == staleSlot)<br>                slotToExpunge = i;<br>            <span class="hljs-comment">//垃圾清理</span><br>            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><span class="hljs-comment">//更新slotToExpunge</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span> &amp;&amp; slotToExpunge == staleSlot)<br>            slotToExpunge = i;<br>    &#125;<br><br>    <span class="hljs-comment">// staleSlot位置放入新的Entry</span><br>    tab[staleSlot].value = <span class="hljs-literal">null</span>;<br>    tab[staleSlot] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);<br><br>    <span class="hljs-comment">// 如果slotToExpunge == staleSlot 说明没有需要清理的过期key，不需要进行垃圾清理。</span><br>    <span class="hljs-keyword">if</span> (slotToExpunge != staleSlot)<br>        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="过期Key的清理"><a href="#过期Key的清理" class="headerlink" title="过期Key的清理"></a>过期Key的清理</h4><h5 id="探测式清理（expungeStaleEntry）"><a href="#探测式清理（expungeStaleEntry）" class="headerlink" title="探测式清理（expungeStaleEntry）"></a>探测式清理（expungeStaleEntry）</h5><p>探测式清理主要做两个工作：</p><ol><li>清理staleSlot所在的那一段<strong>连续的不为null的Entry</strong>中key过期的Entry</li><li>因为清理会空出来一些位置，所以之前set的时候因为hash冲突，会有些key并不在hash &amp; (len-1) 的位置上，所以需要重新计算位置。这样做的目的是尽可能的让key的位置接近hash &amp; (len-1)，在get，set的时候效率会更高一些。</li></ol><p>expungeStaleEntry函数返回的是staleStole右边第一个Entry为null的位置，这个值在启发式清理里会用到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">expungeStaleEntry</span><span class="hljs-params">(<span class="hljs-type">int</span> staleSlot)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br><br>    <span class="hljs-comment">// 清空staleSlot位置的entry</span><br>    tab[staleSlot].value = <span class="hljs-literal">null</span>;<br>    tab[staleSlot] = <span class="hljs-literal">null</span>;<br>    size--;<br><br>    <span class="hljs-comment">// 当遇到key为null时rehash</span><br>    Entry e;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = nextIndex(staleSlot, len);<br>         (e = tab[i]) != <span class="hljs-literal">null</span>;<br>         i = nextIndex(i, len)) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>            e.value = <span class="hljs-literal">null</span>;<br>            tab[i] = <span class="hljs-literal">null</span>;<br>            size--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> k.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (h != i) &#123;<br>                tab[i] = <span class="hljs-literal">null</span>;<br>                <span class="hljs-comment">//找到离h最近的位置放，最坏的情况是仍然放在i位置</span><br>                <span class="hljs-keyword">while</span> (tab[h] != <span class="hljs-literal">null</span>)<br>                    h = nextIndex(h, len);<br>                tab[h] = e;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//这时候tab[i] = null</span><br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="启发式清理（cleanSomeSlots）"><a href="#启发式清理（cleanSomeSlots）" class="headerlink" title="启发式清理（cleanSomeSlots）"></a>启发式清理（cleanSomeSlots）</h5><p>启发式清理就是从i位置开始向后遍历log(n)次，如果遇到过期的key，就进行探测式清理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cleanSomeSlots</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-keyword">do</span> &#123;<br>        i = nextIndex(i, len);<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == <span class="hljs-literal">null</span>) &#123;<br>            n = len;<br>            removed = <span class="hljs-literal">true</span>;<br>            i = expungeStaleEntry(i);<br>        &#125;<br>        <span class="hljs-comment">//n&gt;&gt;&gt;=1 每次会将n右移一位，一共会右移logn次</span><br>    &#125; <span class="hljs-keyword">while</span> ( (n &gt;&gt;&gt;= <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> removed;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：探测式清理和启发式清理都不能保证完全清理整个table中的所有过期key，只能清理局部的过期key</strong></p><h4 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h4><p>rehash会先对table（Entry数组）进行一次全面的垃圾清理（expungeStaleEntries）,然后如果size &gt;&#x3D; threshold - threshold &#x2F; 4则进行扩容。</p><p>因为threshold&#x3D;len * 2&#x2F;3,所以相当于size &gt;&#x3D; len * 1&#x2F;2。</p><p>至于为什么是 size &gt;&#x3D; threshold * 3&#x2F;4 官方是这么解释的：</p><blockquote><p>Use lower threshold for doubling to avoid hysteresis</p><p>使用较低的阈值来避免滞后。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rehash</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//进行全面的垃圾清理</span><br>    expungeStaleEntries();<br>    <span class="hljs-comment">//size &gt;= threshold * 3/4 = len * 1/2</span><br>    <span class="hljs-keyword">if</span> (size &gt;= threshold - threshold / <span class="hljs-number">4</span>)<br>        resize();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">expungeStaleEntries</span><span class="hljs-params">()</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; len; j++) &#123;<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[j];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == <span class="hljs-literal">null</span>)<br>            expungeStaleEntry(j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ThreadLocalMap-getEntry"><a href="#ThreadLocalMap-getEntry" class="headerlink" title="ThreadLocalMap.getEntry()"></a>ThreadLocalMap.getEntry()</h3><p>getEntry方法返回key对应的Entry</p><p>如果i位置没找到对应的key，就向后找，如果遇到失效key，就执行垃圾清理。最后如果没找到就返回null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> table[i];<br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == key)<br>        <span class="hljs-keyword">return</span> e;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">//e == null || e.get() != key</span><br>        <span class="hljs-keyword">return</span> getEntryAfterMiss(key, i, e);<br>&#125;<br><br><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntryAfterMiss</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, <span class="hljs-type">int</span> i, Entry e)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br><br>    <span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span>) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-keyword">if</span> (k == key)<br>            <span class="hljs-keyword">return</span> e;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>)<br>            expungeStaleEntry(i);<br>        <span class="hljs-keyword">else</span><br>            i = nextIndex(i, len);<br>        e = tab[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ThreadLocalMap-remove"><a href="#ThreadLocalMap-remove" class="headerlink" title="ThreadLocalMap.remove()"></a>ThreadLocalMap.remove()</h3><p>删除某个key对应的entry</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>         e != <span class="hljs-literal">null</span>;<br>         e = tab[i = nextIndex(i, len)]) &#123;<br>        <span class="hljs-keyword">if</span> (e.get() == key) &#123;<br>            <span class="hljs-comment">//将e的引用设为null</span><br>            e.clear();<br>            <span class="hljs-comment">//垃圾清理的时候会将table[i]清理掉</span><br>            expungeStaleEntry(i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ThreadLocal-set"><a href="#ThreadLocal-set" class="headerlink" title="ThreadLocal.set()"></a>ThreadLocal.set()</h2><p>取到当前线程的ThreadLocalMap，调用ThreadLocalMap.set()方法插入值，该方法前面已经分析过了，这里就不再赘述了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>    map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>    createMap(t, value);<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>    t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ThreadLocal-get"><a href="#ThreadLocal-get" class="headerlink" title="ThreadLocal.get()"></a>ThreadLocal.get()</h2><p>取到当前线程的ThreadLocalMap，再调用ThreadLocalMap.getEntry()方法得到Entry。如果得到的是map为nul或者e为null时，就调用ThreadLocal.setInitialValue()方法，如果为这个ThreadLocal设置过初始值的话，就会设置value为初始值，并返回。</p><p>ThreadLocal.setInitialValue() 和 ThreadLocal.set() 基本一样，这里也就不再赘述了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//找到当前的线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">//获取ThreadLocalMap</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//map不为null,则获取对应的Entry </span><br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//返回该Entry里的Object</span><br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//当map为null 或者 e为null时,需要执行这一步 </span><br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br><br><span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-comment">//如果map不为null，就将initialVal设置成对应的Object，插入map。</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-comment">//如果map为null，为t线程创建ThreadLocalMap,并初始化</span><br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><span class="hljs-comment">//如果不指定的话，初始值就是null</span><br><span class="hljs-keyword">protected</span> T <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="为ThreadLocal设置初始值"><a href="#为ThreadLocal设置初始值" class="headerlink" title="为ThreadLocal设置初始值"></a>为ThreadLocal设置初始值</h2><p>可以通过 <strong>ThreadLocal.withInitial(…)</strong> 来为ThreadLocal设置初始值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; ThreadLocal&lt;S&gt; <span class="hljs-title function_">withInitial</span><span class="hljs-params">(Supplier&lt;? extends S&gt; supplier)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuppliedThreadLocal</span>&lt;&gt;(supplier);<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SuppliedThreadLocal</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadLocal</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Supplier&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>&gt; supplier;<br><br>    SuppliedThreadLocal(Supplier&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>&gt; supplier) &#123;<br>        <span class="hljs-built_in">this</span>.supplier = Objects.requireNonNull(supplier);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> T <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> supplier.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到SuppliedThreadLocal继承了ThreadLocal，实现了它的initialValue方法，return的是supplier.get()</p><p>那么这个Supplier是啥呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Supplier</span>&lt;T&gt; &#123;<br>    T <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实就是一个函数式接口，实现它的get方法返回你要的东西，也就是我们需要的初始值。</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="ThreadLocal中的AtomicInteger为什么是private"><a href="#ThreadLocal中的AtomicInteger为什么是private" class="headerlink" title="ThreadLocal中的AtomicInteger为什么是private"></a>ThreadLocal中的AtomicInteger为什么是private</h2><p>如果不是private的话，每新建一个ThreadLocal对象都会生成新的AtomicInteger，这样算出的hashcode就不对了。</p><h2 id="ThreadLocalMap为什么设计为ThreadLocal的内部类"><a href="#ThreadLocalMap为什么设计为ThreadLocal的内部类" class="headerlink" title="ThreadLocalMap为什么设计为ThreadLocal的内部类"></a>ThreadLocalMap为什么设计为ThreadLocal的内部类</h2><ul><li>ThreadLocalMap在Thread中默认为null</li><li>操作ThreadLocal的时候会检查线程中的ThreadLocalMap是否为null，如果为null就新建一个。</li><li>这样做的好处是可以实现ThreadLocalMap的按需加载，不会浪费资源。</li><li>如果设计在Thread内，那么在new Thread的时候就要创建出ThreadLocalMap，但如果用不到的话，就会浪费资源。</li></ul><h2 id="Entry为什么是弱引用WearReference"><a href="#Entry为什么是弱引用WearReference" class="headerlink" title="Entry为什么是弱引用WearReference"></a>Entry为什么是弱引用WearReference</h2><p>首先，弱引用增加了ThreadLocal的复杂度—-在get、set的时候都要判断key是否为null，还要考虑过期key的清理，还有可能造成内存泄露的问题。还需要考虑要用的value的key被GC了的情况，那么为什么要这么设计呢？</p><p>我认为：</p><ul><li><p>如果是强引用就会形成这么个引用链：Thread-&gt;ThreadLocalMap-&gt;Entry-&gt;[ThreadLocal,Value]，那么如果使用者用完不<strong>手动将Entry设为null</strong>（设为null的话GC的时候通过可达性分析是可以清理掉ThreadLocal的）的话，在使用ThreadLoal的线程全部结束前，ThreadLocal对象是一直存在的。</p></li><li><p>如果使用者粗心大意，没有在用完后将Entry设为null，那么可能会造成严重的内存泄漏（引用的ThreadLocal和value后面不再需要，白白占用内存空间），<strong>且只会比弱引用更严重</strong>，并且<strong>难以修复</strong>（因为都是强引用，GC的时候不会清理掉）</p></li><li><p>为了避免使用者的粗心，所以设计人员才将Entry设置为弱引用，在get、set、扩容等操作时，都会进行失效key的清理，虽然一定程度上增加了复杂度，损失了一点性能，但能很大程度上避免内存泄漏。</p></li><li><p>同时，在使用ThreadLocal的时候，我们一般也要在用完后进行**手动的remove()**，这样其实即使是弱引用，也不用担心会发生内存泄漏。</p></li><li><p>分析到这里我们也发现了：不管是弱引用还是强引用都要<strong>手动释放引用</strong>。</p><p>但如果使用者忘了，如果是弱引用的话，可以通过在get、set、扩容等方法中穿插清理失效key，这能在很大程度上减缓内存泄漏带来的影响。但如果是强引用的话，就没啥好的办法了（也许只能在jvm的堆快满了的时候进行full gc才会清理调它们），极端情况下，可能会对系统造成严重的影响。   </p><p>但如果使用者有及时释放的好习惯的话，在get、set、扩容等方法中寻找到key&#x3D;&#x3D;null的情况就很少了，算下来其实也不会浪费多少性能。</p></li></ul><h2 id="ThreadLocal为什么需要定义成static"><a href="#ThreadLocal为什么需要定义成static" class="headerlink" title="ThreadLocal为什么需要定义成static"></a>ThreadLocal为什么需要定义成static</h2><p>ThreadLocal 类的目的是为每个线程单独维护一个变量的值，避免线程间对同一变量的竞争访问，适用于一个变量在每个线程中需要有自己独立的值的场合。</p><p>如果把 ThreadLocal 声明为非静态，则在含有 ThreadLocal 变量的的每个实例中都会产生一个新对象，这就起不到对应的效果了（通过一个ThreadLocal在不同的线程中获取不同的值）。</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>在访问不到的数据被回收之前，内存泄漏确实是存在的，但是在进行get、set、扩容等操作时，都会检查失效key的清理，一般在使用的时候，用完要手动remove，所以，内存泄漏完全没必要过于担心。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="用户信息保存"><a href="#用户信息保存" class="headerlink" title="用户信息保存"></a>用户信息保存</h2><p>这是我在面试阿里的时候遇到的面试题，题目大致是这样的：</p><p><strong>controller层在处理用户请求的时候，如果方法里面不写参数，怎么知道当前的用户是谁。</strong></p><p>解答：在前后端分离的项目中（现在绝大多数都是前后端分离），用户登录后，用户信息会保存在Session或者Token中。当我们需要用户信息的时候，拿Session来说，我们可以在接口参数中加上HttpServletRequest，调用 getSession方法获取信息，但是如果且每一个需要用户信息的接口都要加上这个参数，才能获取Session，这样实现就比较麻烦。</p><p>在实际的系统设计中，一般都会在拦截器中使用ThreadLocal，保存用户信息。那么当前线程在任何地方如果需要拿到用户信息都可以使用ThreadLocal的get()方法 。</p><h2 id="Spring-单例模式下的线程安全问题"><a href="#Spring-单例模式下的线程安全问题" class="headerlink" title="Spring 单例模式下的线程安全问题"></a>Spring 单例模式下的线程安全问题</h2><p>在Spring的Web项目中,Dao层一般都是单例，但spring的单例指的是在Bean容器中只有一个对象，它并不能保证线程安全。当多线程线程请求打上来的时候，因为负责数据库连接的Connection只有一个，如果每个请求线程都去连接数据库，就会造成线程不安全的问题。</p><p>Spring的解决方案就是采用ThreadLocal方法，当每个请求线程使用Connection的时候， 都会从ThreadLocal获取一次，如果为null，说明没有进行过数据库连接，连接后存入ThreadLocal中，如此一来，每一个请求线程都保存有一份自己的Connection。于是便解决了线程安全问题</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://juejin.cn/post/6844903648800014349#heading-5">为什么使用0x61c88647</a></p><p><a href="https://juejin.cn/post/6844904146127044622">万字图文深度解析ThreadLocal</a></p><p><a href="https://www.modb.pro/db/194154">为什么ThreadLocal容易导致内存泄漏？</a></p><p><a href="https://zhuanlan.zhihu.com/p/489079713">一文读懂ThreadLocal</a></p>]]></content>
    
    
    <categories>
      
      <category>Java多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java多线程</tag>
      
      <tag>ThreadLocal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ClassCastException之同类型bean无法进行类型转换的问题</title>
    <link href="/2022/05/12/%E5%90%8C%E7%B1%BB%E5%9E%8Bbean%E6%97%A0%E6%B3%95%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2022/05/12/%E5%90%8C%E7%B1%BB%E5%9E%8Bbean%E6%97%A0%E6%B3%95%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在进行微信公众号开发的时候，需要把接收的xml转换成bean，用到了Xstream类型转换框架。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">xmlToBean</span><span class="hljs-params">(String resultXml, Class clazz)</span> &#123;<br>    <span class="hljs-type">XStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DomDriver</span>());<br>    XStream.setupDefaultSecurity(stream);<br>    stream.allowTypes(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;clazz&#125;);<br>    stream.processAnnotations(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;clazz&#125;);<br>    stream.setMode(XStream.NO_REFERENCES);<br>    stream.alias(<span class="hljs-string">&quot;xml&quot;</span>, clazz);<br>    <span class="hljs-keyword">return</span> (T) stream.fromXML(resultXml);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">MessageTextEntity</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> XmlUtil.xmlToBean(requestBody, MessageTextEntity.class);<br></code></pre></td></tr></table></figure><p>可以看到这里需要进行一个同类型的转换，但是出现了以下报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">java.lang.ClassCastException: com.ljf.ploughthewaves.domain.wx.model.MessageTextEntity cannot be cast to com.ljf.ploughthewaves.domain.wx.model.MessageTextEntity<br>at com.ljf.ploughthewaves.interfaces.WxPortalController.post(WxPortalController.java:<span class="hljs-number">75</span>) ~[classes/:na]<br>at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:<span class="hljs-number">1.8</span><span class="hljs-number">.0_311</span>]<br>at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="hljs-number">62</span>) ~[na:<span class="hljs-number">1.8</span><span class="hljs-number">.0_311</span>]<br>at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="hljs-number">43</span>) ~[na:<span class="hljs-number">1.8</span><span class="hljs-number">.0_311</span>]<br>at java.lang.reflect.Method.invoke(Method.java:<span class="hljs-number">498</span>) ~[na:<span class="hljs-number">1.8</span><span class="hljs-number">.0_311</span>]<br>at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:<span class="hljs-number">205</span>) [spring-web-<span class="hljs-number">5.3</span><span class="hljs-number">.13</span>.jar:<span class="hljs-number">5.3</span><span class="hljs-number">.13</span>]<br>at ......<br><br></code></pre></td></tr></table></figure><p>可以注意到这是<strong>同类型bean</strong>转换出错。</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>写了个测试类模拟了一下，发现在测试类中竟然无法复现这个问题……</p><p>那么问题一定就出在业务代码中，回顾一下Java是如何判断两个类相等的：</p><p><strong>类的全限定名+类的加载器</strong></p><p>试着在代码中打印一下每一步的类加载器发现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">类加载器<span class="hljs-number">1</span>: org.springframework.boot.devtools.restart.classloader.RestartClassLoader@53a644b8<br>类加载器<span class="hljs-number">2</span>：org.springframework.boot.devtools.restart.classloader.RestartClassLoader@53a644b8<br>类加载器<span class="hljs-number">3</span>：sun.misc.Launcher$AppClassLoader@18b4aac2<br></code></pre></td></tr></table></figure><p><strong>xmltobean方法生成的对象的类加载器和需要转换的bean的类加载器不一样</strong>，所以导致了类不能转换。</p><p>可以看到bean的类加载器被devtools替换成了它自己的类加载器。</p><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>禁用spring-boot-devtools 或者把restart属性设置为false</p>]]></content>
    
    
    <categories>
      
      <category>Bugs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bugs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM（面经）</title>
    <link href="/2022/05/09/JVM%EF%BC%88%E9%9D%A2%E7%BB%8F%EF%BC%89/"/>
    <url>/2022/05/09/JVM%EF%BC%88%E9%9D%A2%E7%BB%8F%EF%BC%89/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>面经整理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis（面经）</title>
    <link href="/2022/05/09/Redis%EF%BC%88%E9%9D%A2%E7%BB%8F%EF%BC%89/"/>
    <url>/2022/05/09/Redis%EF%BC%88%E9%9D%A2%E7%BB%8F%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="redis单线程为什么快-1"><a href="#redis单线程为什么快-1" class="headerlink" title="redis单线程为什么快 1"></a>redis单线程为什么快 <em>1</em></h1><h1 id="redisson分布式锁watch机制-1"><a href="#redisson分布式锁watch机制-1" class="headerlink" title="redisson分布式锁watch机制 1"></a>redisson分布式锁watch机制 <em>1</em></h1><h1 id="redis的应用场景有哪些-1"><a href="#redis的应用场景有哪些-1" class="headerlink" title="redis的应用场景有哪些 1"></a>redis的应用场景有哪些 <em>1</em></h1>]]></content>
    
    
    <categories>
      
      <category>面经整理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库（面经）</title>
    <link href="/2022/05/07/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E9%9D%A2%E7%BB%8F%EF%BC%89/"/>
    <url>/2022/05/07/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E9%9D%A2%E7%BB%8F%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="innodb-update-和-select的加锁情况"><a href="#innodb-update-和-select的加锁情况" class="headerlink" title="innodb update 和 select的加锁情况"></a>innodb update 和 select的加锁情况</h2><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="sql回滚怎么实现-1"><a href="#sql回滚怎么实现-1" class="headerlink" title="sql回滚怎么实现 1"></a>sql回滚怎么实现 <em>1</em></h2><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="索引的底层结构是什么，有什么好处和坏处？-1"><a href="#索引的底层结构是什么，有什么好处和坏处？-1" class="headerlink" title="索引的底层结构是什么，有什么好处和坏处？ 1"></a>索引的底层结构是什么，有什么好处和坏处？ <em>1</em></h2><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="如果访问量过大，该使用什么措施-1"><a href="#如果访问量过大，该使用什么措施-1" class="headerlink" title="如果访问量过大，该使用什么措施 1"></a>如果访问量过大，该使用什么措施 <em>1</em></h2>]]></content>
    
    
    <categories>
      
      <category>面经整理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列（面经）</title>
    <link href="/2022/05/07/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88%E9%9D%A2%E7%BB%8F%EF%BC%89/"/>
    <url>/2022/05/07/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88%E9%9D%A2%E7%BB%8F%EF%BC%89/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>面经整理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统（面经）</title>
    <link href="/2022/05/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E9%9D%A2%E7%BB%8F%EF%BC%89/"/>
    <url>/2022/05/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E9%9D%A2%E7%BB%8F%EF%BC%89/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>面经整理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程(面经)</title>
    <link href="/2022/05/07/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E9%9D%A2%E7%BB%8F%EF%BC%89/"/>
    <url>/2022/05/07/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E9%9D%A2%E7%BB%8F%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程与线程的区别-1"><a href="#进程与线程的区别-1" class="headerlink" title="进程与线程的区别 1"></a>进程与线程的区别 <em>1</em></h2><h2 id="进程间的通信方式有哪些-1"><a href="#进程间的通信方式有哪些-1" class="headerlink" title="进程间的通信方式有哪些 1"></a>进程间的通信方式有哪些 <em>1</em></h2><h2 id="共享内存的原理-1"><a href="#共享内存的原理-1" class="headerlink" title="共享内存的原理 1"></a>共享内存的原理 <em>1</em></h2><h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h2 id="ReenteredLock用了Unsafe类的什么方法-1"><a href="#ReenteredLock用了Unsafe类的什么方法-1" class="headerlink" title="ReenteredLock用了Unsafe类的什么方法 1"></a>ReenteredLock用了Unsafe类的什么方法 <em>1</em></h2><h1 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h1><h2 id="Synchronized与ReenteredLock有什么区别-1"><a href="#Synchronized与ReenteredLock有什么区别-1" class="headerlink" title="Synchronized与ReenteredLock有什么区别 1"></a>Synchronized与ReenteredLock有什么区别 <em>1</em></h2><h1 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h1><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="如何打破线程池先放队列再扩容的逻辑，有什么框架实现了-1"><a href="#如何打破线程池先放队列再扩容的逻辑，有什么框架实现了-1" class="headerlink" title="如何打破线程池先放队列再扩容的逻辑，有什么框架实现了 1"></a>如何打破线程池先放队列再扩容的逻辑，有什么框架实现了 <em>1</em></h2><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h2 id="ThreadLocal的实现原理-1"><a href="#ThreadLocal的实现原理-1" class="headerlink" title="ThreadLocal的实现原理 1"></a>ThreadLocal的实现原理 <em>1</em></h2>]]></content>
    
    
    <categories>
      
      <category>面经整理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
      <tag>Java多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络（面经）</title>
    <link href="/2022/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E9%9D%A2%E7%BB%8F%EF%BC%89/"/>
    <url>/2022/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E9%9D%A2%E7%BB%8F%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="url为什么有时候获取的是网页有时候直接下载图片-x2F-文件-1"><a href="#url为什么有时候获取的是网页有时候直接下载图片-x2F-文件-1" class="headerlink" title="url为什么有时候获取的是网页有时候直接下载图片&#x2F;文件 1"></a>url为什么有时候获取的是网页有时候直接下载图片&#x2F;文件 <em>1</em></h2><h2 id="http和https的区别-1"><a href="#http和https的区别-1" class="headerlink" title="http和https的区别 1"></a>http和https的区别 <em>1</em></h2><h2 id="http2-0-相较于1-0-有什么改动-1"><a href="#http2-0-相较于1-0-有什么改动-1" class="headerlink" title="http2.0 相较于1.0 有什么改动 1"></a>http2.0 相较于1.0 有什么改动 <em>1</em></h2><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="讲一下TCP和UDP-1"><a href="#讲一下TCP和UDP-1" class="headerlink" title="讲一下TCP和UDP 1"></a>讲一下TCP和UDP <em>1</em></h2><h2 id="三次握手-1"><a href="#三次握手-1" class="headerlink" title="三次握手 1"></a>三次握手 <em>1</em></h2><h2 id="四次挥手-1"><a href="#四次挥手-1" class="headerlink" title="四次挥手 1"></a>四次挥手 <em>1</em></h2><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="子网掩码-1"><a href="#子网掩码-1" class="headerlink" title="子网掩码 1"></a>子网掩码 <em>1</em></h2><h2 id="子网和外网传输区别-1"><a href="#子网和外网传输区别-1" class="headerlink" title="子网和外网传输区别 1"></a>子网和外网传输区别 <em>1</em></h2><h2 id="路由表大概长啥样-1"><a href="#路由表大概长啥样-1" class="headerlink" title="路由表大概长啥样 1"></a>路由表大概长啥样 <em>1</em></h2><h2 id="NAT是什么，如何工作的-1"><a href="#NAT是什么，如何工作的-1" class="headerlink" title="NAT是什么，如何工作的 1"></a>NAT是什么，如何工作的 <em>1</em></h2><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1>]]></content>
    
    
    <categories>
      
      <category>面经整理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础(面经)</title>
    <link href="/2022/05/07/Java%E5%9F%BA%E7%A1%80%EF%BC%88%E9%9D%A2%E7%BB%8F%EF%BC%89/"/>
    <url>/2022/05/07/Java%E5%9F%BA%E7%A1%80%EF%BC%88%E9%9D%A2%E7%BB%8F%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="所有异常的共同祖先是？运行时异常有哪几个？"><a href="#所有异常的共同祖先是？运行时异常有哪几个？" class="headerlink" title="所有异常的共同祖先是？运行时异常有哪几个？"></a>所有异常的共同祖先是？运行时异常有哪几个？</h2>]]></content>
    
    
    <categories>
      
      <category>面经整理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka</title>
    <link href="/2022/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kafka/"/>
    <url>/2022/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kafka/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么要用消息队列"><a href="#为什么要用消息队列" class="headerlink" title="为什么要用消息队列"></a>为什么要用消息队列</h1><h2 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h2><p>如果服务调用链路过长，会导致用户等待时间过长，这时一些不需要及时完成的操作，就可以进行异步处理，减少用户等待时间。</p><p>比如一个抽奖项目，有参与<strong>抽奖–中奖–发奖</strong>这三个流程，可以中奖后直接返回中奖结果给用户，然后向消息队列发送消息，发奖的服务再去消息队列中取对应的消息，完成发奖操作。</p><h2 id="削峰填谷"><a href="#削峰填谷" class="headerlink" title="削峰填谷"></a>削峰填谷</h2><p>在类似秒杀活动中,为了避免流量一下子打到服务端，可以前置一个消息队列当作缓冲，服务端尽最大努力取消息队列消费消息，一些超时的请求可以直接返回错误。</p><h2 id="服务解耦"><a href="#服务解耦" class="headerlink" title="服务解耦"></a>服务解耦</h2><p>在商城项目中，用户下订单后，后端会根据生成的订单进行一系列操作，比如：vip等级变更，加积分等，如果这时候公司又要加一些其他服务，那么可能会影响到订单服务。这时候可以加一个发布-订阅模式的消息队列，订单服务生成订单后直接丢到消息队列里，其他下游服务需要订单信息的话再从消息队列中取就行了。</p><h1 id="消息队列会带来哪些问题，如何解决"><a href="#消息队列会带来哪些问题，如何解决" class="headerlink" title="消息队列会带来哪些问题，如何解决"></a>消息队列会带来哪些问题，如何解决</h1><h2 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h2><p>Kafka中的多副本机制允许Partition拥有多个副本，多个副本间数据一致，正常情况下Producer和Consumer都和Leader进行交互。当一个Broker挂掉并且Leader就在这个Broker中，可以在剩余副本中重新选举Leader，来保证高可用性和安全性。</p><blockquote><p>为什么只能和leader交互？ 如果可以随意读写每个follower，就要考虑数据的一致性，会增加系统复杂度，降低容错性。</p></blockquote><h2 id="消息顺序"><a href="#消息顺序" class="headerlink" title="消息顺序"></a>消息顺序</h2><p>在一些业务中需要保证消息被消费的顺序，在Producer生产消息的时候可以把这些消息指定相同的key，这样它们都会进入同一个Partition，这样就保证了有序性。</p><h2 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h2><blockquote><p>消息丢失可以从以下三个方面考虑：</p></blockquote><h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><blockquote><p>生产者发送的消息因为网络原因并没有到达Broker导致消息丢失</p></blockquote><p>在调用send()函数发送完消息后，为了确保消息到达Broker，可以添加回调函数知道Broker时候接收到。另外可以把<strong>retries</strong>参数设置成&gt;3，可以实现自动重发消息。</p><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><blockquote><p>消费者接收消息后，自动提交offset，这时候消费者宕机了，就会导致消息丢失</p></blockquote><p>关闭自动提交offset，等处理完业务后，再手动提交。但是如果业务完成后宕机了，没有提交成功，当再次开始处理消息的时候，就会导致重复消费的问题。</p><h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><blockquote><p>如果一个leader挂掉了，这时候数据还没来得及同步到副本中，信息就丢失了。</p></blockquote><p>可以设置 ：</p><ul><li><p>acks &#x3D; all</p><p>所有副本都<strong>接收</strong>消息后，才算发送成功</p></li><li><p>replication.factor &gt;&#x3D; 3</p><p>副本数量大于3</p></li><li><p>min.insync.replicas &gt; 1</p><p>消息至少被<strong>写入</strong>两个副本才算发送成功</p></li><li><p>unclean.leader.election.enable &#x3D; false</p><p>leader故障后只从和leader完全同步的副本中选举新leader</p></li></ul><h2 id="消息重复"><a href="#消息重复" class="headerlink" title="消息重复"></a>消息重复</h2><blockquote><p>Consumer消费完消息后，还没提交就挂了</p></blockquote><p>设计全局ID，做幂等性校验。</p><h2 id="消息堆积"><a href="#消息堆积" class="headerlink" title="消息堆积"></a>消息堆积</h2><ul><li>看能否提高服务端处理消息都速度，比如多次数据库插入，优化成批量插入</li><li>扩容，增加topic队列和消费者数量，<strong>（一个队列只会分配给一个消费者）</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息队列</tag>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在阿里云服务器上部署docker</title>
    <link href="/2022/05/04/%E5%9C%A8%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2docker/"/>
    <url>/2022/05/04/%E5%9C%A8%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2docker/</url>
    
    <content type="html"><![CDATA[<h1 id="在阿里云上部署docker"><a href="#在阿里云上部署docker" class="headerlink" title="在阿里云上部署docker"></a>在阿里云上部署docker</h1><h2 id="1-系统版本要求"><a href="#1-系统版本要求" class="headerlink" title="1. 系统版本要求"></a>1. 系统版本要求</h2><ul><li><p>服务器版本<strong>CentOS 8.x</strong> </p></li><li><p>服务器必须是 <strong>x86 64位</strong>系统</p></li><li><p>查看系统的内核版本</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">[root@iZ8vbd7wo3mhy6gadb8egyZ ~]# uname -r<br>4.18.0-348.7.1.el8_5.x86_64<br></code></pre></td></tr></table></figure></li><li><p>将yum更新到最新版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@iZ8vbd7wo3mhy6gadb8egyZ ~]# sudo yum update<br>Last metadata expiration check: 1:22:43 ago on Wed 04 May 2022 03:01:02 PM CST.<br>Dependencies resolved.<br>Nothing to do.<br>Complete!<br></code></pre></td></tr></table></figure></li></ul><h2 id="2-安装Docker"><a href="#2-安装Docker" class="headerlink" title="2. 安装Docker"></a>2. 安装Docker</h2><h3 id="1-安装依赖包"><a href="#1-安装依赖包" class="headerlink" title="1. 安装依赖包"></a>1. 安装依赖包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@iZ8vbd7wo3mhy6gadb8egyZ ~]# sudo yum install -y yum-utils device-mapper-persistent-data lvm2<br></code></pre></td></tr></table></figure><p><em>本人因为已经安装过，就不展示对应的内容了，一般来说看到Complete就代表完成了。</em></p><h3 id="2-添加yum仓库"><a href="#2-添加yum仓库" class="headerlink" title="2. 添加yum仓库"></a>2. 添加yum仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@iZ8vbd7wo3mhy6gadb8egyZ ~]# sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure><h3 id="3-安装Docker"><a href="#3-安装Docker" class="headerlink" title="3. 安装Docker"></a>3. 安装Docker</h3><h4 id="3-1-默认安装最新版"><a href="#3-1-默认安装最新版" class="headerlink" title="3.1 默认安装最新版"></a>3.1 默认安装最新版</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@iZ8vbd7wo3mhy6gadb8egyZ ~]# sudo yum install docker-ce<br></code></pre></td></tr></table></figure><h4 id="3-2-安装指定版本"><a href="#3-2-安装指定版本" class="headerlink" title="3.2 安装指定版本"></a>3.2 安装指定版本</h4><p>查看仓库中的Docker版本并安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@iZ8vbd7wo3mhy6gadb8egyZ ~]# yum list docker-ce --showduplicates | sort -r<br>Last metadata expiration check: 1:31:35 ago on Wed 04 May 2022 03:01:02 PM CST.<br>Installed Packages<br>docker-ce.x86_64               3:20.10.9-3.el8                 docker-ce-stable <br>docker-ce.x86_64               3:20.10.8-3.el8                 docker-ce-stable <br>docker-ce.x86_64               3:20.10.7-3.el8                 docker-ce-stable <br>docker-ce.x86_64               3:20.10.6-3.el8                 docker-ce-stable <br>docker-ce.x86_64               3:20.10.5-3.el8                 docker-ce-stable <br>docker-ce.x86_64               3:20.10.4-3.el8                 docker-ce-stable <br>docker-ce.x86_64               3:20.10.3-3.el8                 docker-ce-stable <br>docker-ce.x86_64               3:20.10.2-3.el8                 docker-ce-stable <br>docker-ce.x86_64               3:20.10.14-3.el8                docker-ce-stable <br>docker-ce.x86_64               3:20.10.14-3.el8                @docker-ce-stable<br>docker-ce.x86_64               3:20.10.1-3.el8                 docker-ce-stable <br>docker-ce.x86_64               3:20.10.13-3.el8                docker-ce-stable <br>docker-ce.x86_64               3:20.10.12-3.el8                docker-ce-stable <br>docker-ce.x86_64               3:20.10.11-3.el8                docker-ce-stable <br>docker-ce.x86_64               3:20.10.10-3.el8                docker-ce-stable <br>docker-ce.x86_64               3:20.10.0-3.el8                 docker-ce-stable <br>docker-ce.x86_64               3:19.03.15-3.el8                docker-ce-stable <br>docker-ce.x86_64               3:19.03.14-3.el8                docker-ce-stable <br>docker-ce.x86_64               3:19.03.13-3.el8                docker-ce-stable <br>Available Packages<br><br>[root@iZ8vbd7wo3mhy6gadb8egyZ ~]# sudo yum install docker-ce-20.10.11.ce<br></code></pre></td></tr></table></figure><h3 id="4-启动Docker并添加开机启动"><a href="#4-启动Docker并添加开机启动" class="headerlink" title="4. 启动Docker并添加开机启动"></a>4. 启动Docker并添加开机启动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@iZ8vbd7wo3mhy6gadb8egyZ ~]# sudo systemctl start docker<br>[root@iZ8vbd7wo3mhy6gadb8egyZ ~]# systemctl enable docker<br></code></pre></td></tr></table></figure><h2 id="2-Docker可视化界面安装"><a href="#2-Docker可视化界面安装" class="headerlink" title="2. Docker可视化界面安装"></a>2. Docker可视化界面安装</h2><h3 id="1-Portainer汉化包的下载与上传"><a href="#1-Portainer汉化包的下载与上传" class="headerlink" title="1. Portainer汉化包的下载与上传"></a>1. Portainer汉化包的下载与上传</h3><h4 id="1-下载"><a href="#1-下载" class="headerlink" title="1. 下载"></a>1. 下载</h4><p>链接：<a href="https://pan.baidu.com/s/1hVvP5msL6LObDAt-v-S-sw?pwd=rj5h">https://pan.baidu.com/s/1hVvP5msL6LObDAt-v-S-sw?pwd=rj5h</a><br>提取码：rj5h</p><h4 id="2-上传"><a href="#2-上传" class="headerlink" title="2. 上传"></a>2. 上传</h4><p>创建目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@iZ8vbd7wo3mhy6gadb8egyZ ~]# mkdir -p /data/portainer/data /data/portainer/public<br></code></pre></td></tr></table></figure><p>将Portainer-CN中的文件上传到data&#x2F;portainer&#x2F;public目录下</p><h3 id="2-拉取Portainer"><a href="#2-拉取Portainer" class="headerlink" title="2. 拉取Portainer"></a>2. 拉取Portainer</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@iZ8vbd7wo3mhy6gadb8egyZ ~]# docker pull portainer/portainer<br></code></pre></td></tr></table></figure><h3 id="3-启动Portainer"><a href="#3-启动Portainer" class="headerlink" title="3. 启动Portainer"></a>3. 启动Portainer</h3><p>需要开启9000端口，可以在服务器安全组中开启。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@iZ8vbd7wo3mhy6gadb8egyZ ~]# docker run -d --restart=always --name portainer -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v /data/portainer/data:/data -v /data/portainer/public:/public portainer/portainer<br></code></pre></td></tr></table></figure><h2 id="4-访问Portainer"><a href="#4-访问Portainer" class="headerlink" title="4. 访问Portainer"></a>4. 访问Portainer</h2><p>在<strong>http:&#x2F;&#x2F;服务器公网ip:9000</strong> 访问</p>]]></content>
    
    
    <categories>
      
      <category>环境部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>环境部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
