<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>猿辅导服务端一面</title>
    <link href="/2022/08/12/%E7%8C%BF%E8%BE%85%E5%AF%BC%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%80%E9%9D%A2/"/>
    <url>/2022/08/12/%E7%8C%BF%E8%BE%85%E5%AF%BC%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="项目相关"><a href="#项目相关" class="headerlink" title="项目相关"></a>项目相关</h1><ol><li>爬虫项目用的网络请求框架是什么</li><li>xxl-job的实现原理</li><li>redis如何实现限流</li></ol><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><ol><li>ACID</li><li>事物的隔离级别，分别解决的什么问题</li><li>RC与RR的实现原理</li><li>undolog有什么用</li><li>redolog有什么用</li><li>redolog和undolog的记录方式有什么区别</li><li>binlog和redolog的区别</li><li>mysql的主从同步</li></ol><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><ol><li>垃圾回收机制</li><li>垃圾收集器了解哪些</li><li>jvm配置看过吗，项目中有没有遇到什么相关问题</li></ol><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><ol><li>讲一下java的锁</li><li>线程之间的同步方式</li><li>介绍一下乐观锁和悲观锁</li></ol><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><ol><li>讲一下IO</li><li>三次握手是在哪一层</li><li>三次握手建立的链接叫什么，学名</li><li>socket里面存的是什么</li></ol><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><ol><li>zset的实现原理</li><li>跳表的实现原理</li></ol><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ol><li>从一个非递减数组中找出目标数字在数组中的起始位置</li><li>实现跳表</li></ol>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hashmap源码解析</title>
    <link href="/2022/08/09/Hashmap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/08/09/Hashmap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Java集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>柠檬微趣Unity3D客户端一面</title>
    <link href="/2022/08/08/%E6%9F%A0%E6%AA%AC%E5%BE%AE%E8%B6%A3Unity3D%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%80%E9%9D%A2/"/>
    <url>/2022/08/08/%E6%9F%A0%E6%AA%AC%E5%BE%AE%E8%B6%A3Unity3D%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><h1 id="项目相关"><a href="#项目相关" class="headerlink" title="项目相关"></a>项目相关</h1><ol><li>抽奖算法的结构</li><li>分库分表具体是怎么做的<h1 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h1></li><li>vector底层</li><li>vector扩容是怎么做的</li><li>map的底层</li><li>vector和map的erase的区别</li><li>map取元素的时间复杂度</li><li>unordered_map取元素的时间复杂度</li></ol><h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><ol><li>Array底层</li><li>ArrayList扩容</li><li>Arraylist和Linkedlist的区别</li><li>什么时候更适合Linkedlist</li><li>值传递和引用传递</li><li>ConcurrentHashmap如何做到线程安全的</li><li>介绍一下gc</li><li>TreeMap底层原理</li></ol><h1 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h1><ol><li>让你设计一个数据库用treemap还是hashmap更好？为什么？<ul><li>选树形结构的。</li><li>能支持范围操作，排序操作，但是平衡树不合适，io太频繁。</li><li>hashmap存在空间浪费，不适合大量数据。</li></ul></li></ol><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ol><li>从1~n中选n-1个数放在数组中，找出没选中的那个数。（数组有序&#x2F;数组无序）</li><li>从1~n中选n-2个数放在数组中，找出没选中的两个数。</li><li>给定二叉树中序遍历和先序遍历，还原二叉树。</li><li>快排</li></ol>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis为什么构建自己的简单动态字符串SDS</title>
    <link href="/2022/06/27/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS/"/>
    <url>/2022/06/27/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS/</url>
    
    <content type="html"><![CDATA[<h1 id="简单动态字符串-SDS"><a href="#简单动态字符串-SDS" class="headerlink" title="简单动态字符串 (SDS)"></a>简单动态字符串 (SDS)</h1><p>SDS 和我们认识的 C 字符串不太一样，之所以没有使用 C 语言的字符串表示，因为 SDS 相比于 C 的原生字符串：</p><p>SDS 不仅可以保存文本数据，还可以保存二进制数据。因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 buf[] 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。<br>SDS 获取字符串长度的时间复杂度是 O(1)。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 len 属性记录了字符串长度，所以复杂度为 O(1)。<br>Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。</p><h1 id="C-语言中的字符串"><a href="#C-语言中的字符串" class="headerlink" title="C 语言中的字符串"></a>C 语言中的字符串</h1><p>C 语言中传统字符串是使用长度为 N+1 的字符数组来表示长度为 N 的字符串，并且字符串数组的最后一个元素总是空字符 ‘\0’。并且获取字符串长度的函数的时间复杂度为O(N)。</p><h1 id="SDS-的定义"><a href="#SDS-的定义" class="headerlink" title="SDS 的定义"></a>SDS 的定义</h1><p>在 Redis 源码文件 sds.h 中定义了 SDS 的结构，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sdshdr</span> &#123;<br>    <span class="hljs-comment">// 记录 buf 数组中已使用的数量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len; <br>    <span class="hljs-comment">// 记录 buf 中未使用的空间数量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> free; <br>    <span class="hljs-comment">// 字符数组，用于保存字符串</span><br>    <span class="hljs-type">char</span> buf[];  <br>&#125;;<br></code></pre></td></tr></table></figure><p>有上面的源码，我们看到 SDS 中也是使用字符数组来存放字符串，但是，它是通过 属性 len 来表示当前字符串的长度。</p><h1 id="SDS-与-C-字符串的区别"><a href="#SDS-与-C-字符串的区别" class="headerlink" title="SDS 与 C 字符串的区别"></a>SDS 与 C 字符串的区别</h1><h2 id="获取字符串长度的复杂度"><a href="#获取字符串长度的复杂度" class="headerlink" title="获取字符串长度的复杂度"></a>获取字符串长度的复杂度</h2><p>因为 C 字符串不记录自身的长度，所以在获取一个 C 字符串的长度时，需要遍历整个字符数组，对遇到的每个字符进行计数，知道遇到代表字符串结尾的空字符串’\0’ 为止，那么，这个操作的复杂度为 O(N)。</p><p>上面的 SDS 结构的源码，我们可知，SDS 字符串通过 len 记录了当前字符串的长度，那么当获取 SDS 的字符串长度的复杂度仅为 O(1)。这就确保了获取字符串长度的工作不会成为 Redis 的性能瓶颈，因为不管字符串多长，其获取长度的复杂度都是O(1)。这或许也是 Redis 快的一个原因吧。</p><h2 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h2><p>我们在日常 Java 开发中，经常会用到字符串的拼接，在 C 语言 和 Redis 中也经常用到字符串的拼接。由于 C 字符串不记录自身长度，这样就带来了一个问题就是，如果在拼接字符串时，如果内存计算不当，就会造成缓冲区溢出。</p><p>由 SDS 的结构我们可知，SDS 有 len 存储了当前长度，还有 free 存储了未使用的长度，这样就简单多了，当操作字符串拼接时，可以先判断一下 free 和需要拼接的字符串，是否能够存的下，如放的下则直接执行，如果放不下，则进行扩容操作。</p><h2 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h2><p>我们上文提的 C 字符串中是以空字符 ‘\0’ 来表示 C 字符串的终止符号。这样字符串里就不能包含空字符，否则最先被读入的空字符将被误认为字符串传结尾，这些限制使得 C 字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件等这样的二进制数据。</p><p>在 Redis 中 SDS 中就不存在此问题，因为在 SDS 中通过 len 属性保存了字符串的长度，所以，在 SDS 中是通过 len 属性的值而不是空字符来判断字符串的是否结束。</p><p>通过使用二进制安全的 SDS，而不是 C 字符串，使得Redis不仅可以保存文本数据，还可以保存任意格式的二进制数据。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在docker上部署kafka</title>
    <link href="/2022/06/21/%E5%9C%A8docker%E4%B8%8A%E9%83%A8%E7%BD%B2kafka/"/>
    <url>/2022/06/21/%E5%9C%A8docker%E4%B8%8A%E9%83%A8%E7%BD%B2kafka/</url>
    
    <content type="html"><![CDATA[<h1 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h1><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">docker pull wurstmeister/kafka<br>docker pull wurstmeister/zookeeper<br></code></pre></td></tr></table></figure><h1 id="启动Zookeeper"><a href="#启动Zookeeper" class="headerlink" title="启动Zookeeper"></a>启动Zookeeper</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d --name zookeeper -p 2181:2181 -t wurstmeister/zookeeper<br></code></pre></td></tr></table></figure><h1 id="启动Kafka"><a href="#启动Kafka" class="headerlink" title="启动Kafka"></a>启动Kafka</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d --name kafka \<br>-p 9092:9092 \<br>-e KAFKA_BROKER_ID=0 \<br>-e KAFKA_ZOOKEEPER_CONNECT=服务器IP:2181 \<br>-e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://服务器IP:9092 \<br>-e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 wurstmeister/kafka<br></code></pre></td></tr></table></figure><h1 id="放行端口"><a href="#放行端口" class="headerlink" title="放行端口"></a>放行端口</h1>]]></content>
    
    
    
    <tags>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka吞吐量为什么那么高</title>
    <link href="/2022/06/20/Kafka%E5%90%9E%E5%90%90%E9%87%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E9%82%A3%E4%B9%88%E9%AB%98/"/>
    <url>/2022/06/20/Kafka%E5%90%9E%E5%90%90%E9%87%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E9%82%A3%E4%B9%88%E9%AB%98/</url>
    
    <content type="html"><![CDATA[<h1 id="顺序读写"><a href="#顺序读写" class="headerlink" title="顺序读写"></a>顺序读写</h1><p>Kafka是将日志记录持久化到本地磁盘中的，一般我们会认为磁盘读写性能差，可能会对Kafka性能如何保证提出质疑。实际上不管是内存还是磁盘，快或慢关键在于寻址的方式，磁盘分为顺序读写与随机读写，内存也一样分为顺序读写与随机读写。基于磁盘的随机读写确实很慢，但磁盘的顺序读写性能却很高，一般而言要高出磁盘随机读写三个数量级，一些情况下磁盘顺序读写性能甚至要高于内存随机读写。</p><p>磁盘的顺序读写是磁盘使用模式中最有规律的，并且操作系统也对这种模式做了大量优化，Kafka就是使用了磁盘顺序读写来提升的性能。Kafka的message是不断追加到本地磁盘文件末尾的，而不是随机的写入，这使得Kafka写入吞吐量得到了显著提升。</p><p>这种方法有一个缺陷—— 没有办法删除数据 ，所以Kafka是不会删除数据的，它会把所有的数据都保留下来，每个消费者（Consumer）对每个Topic都有一个offset用来表示读取到了第几条数据。</p><p>如果不删除硬盘肯定会被撑满，所以Kafka提供了两种策略来删除数据。一是基于时间，二是基于partition文件大小。具体配置可以参看它的配置文档。</p><h1 id="Page-Cache"><a href="#Page-Cache" class="headerlink" title="Page Cache"></a>Page Cache</h1><p>为了优化读写性能，Kafka利用了操作系统本身的Page Cache，就是利用操作系统自身的内存而不是JVM空间内存。这样做的好处有：</p><p>避免Object消耗：如果是使用 Java 堆，Java对象的内存消耗比较大，通常是所存储数据的两倍甚至更多。</p><p>避免GC问题：随着JVM中数据不断增多，垃圾回收将会变得复杂与缓慢，使用系统缓存就不会存在GC问题</p><p>相比于使用JVM或in-memory cache等数据结构，利用操作系统的Page Cache更加简单可靠。首先，操作系统层面的缓存利用率会更高，因为存储的都是紧凑的字节结构而不是独立的对象。其次，操作系统本身也对于Page Cache做了大量优化，提供了 write-behind、read-ahead以及flush等多种机制。再者，即使服务进程重启，系统缓存依然不会消失，避免了in-process cache重建缓存的过程。</p><p>通过操作系统的Page Cache，Kafka的读写操作基本上是基于内存的，读写速度得到了极大的提升。</p><h1 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h1><p>零拷贝技术是指计算机执行操作时，CPU不需要先将数据从某处内存复制到另一个特定区域，这种技术通常用于通过网络传输文件时节省CPU周期和内存带宽。</p><p>那么对于零拷贝而言，并非真的是完全没有数据拷贝的过程，只不过是减少用户态和内核态的切换次数以及CPU拷贝的次数。</p><p>这里，我们了解几种常见的零拷贝技术。</p><h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><p>mmap() 就是在用户态直接引用文件句柄，也就是用户态和内核态共享内核态的数据缓冲区，此时数据不需要复制到用户态空间。当应用程序往 mmap 输出数据时，此时就直接输出到了内核态数据，如果此时输出设备是磁盘的话，会直接写盘（flush间隔是30秒）。</p><h2 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h2><p>对于sendfile 而言，数据不需要在应用程序做业务处理，仅仅是从一个 DMA 设备传输到另一个 DMA设备。 此时数据只需要复制到内核态，用户态不需要复制数据，并且也不需要像 mmap 那样对内核态的数据的句柄（文件引用）。如下图所示：</p><p>从上图我们可以发现（输出设备可以是网卡&#x2F;磁盘驱动），内核态有 2 份数据缓存 。sendfile 是 Linux 2.1 开始引入的，在 Linux 2.4 又做了一些优化。也就是上图中磁盘页缓存中的数据，不需要复制到 Socket 缓冲区，而只是将数据的位置和长度信息存储到 Socket 缓冲区。实际数据是由DMA 设备直接发送给对应的协议引擎，从而又减少了一次数据复制。</p><h1 id="分区分段-索引"><a href="#分区分段-索引" class="headerlink" title="分区分段 + 索引"></a>分区分段 + 索引</h1><p>Kafka的message是按topic分类存储的，topic中的数据又是按照一个一个的partition即分区存储到不同broker节点。每个partition对应了操作系统上的一个文件夹，partition实际上又是按照segment分段存储的。这也非常符合分布式系统分区分桶的设计思想。</p><p>通过这种分区分段的设计，Kafka的message消息实际上是分布式存储在一个一个小的segment中的，每次文件操作也是直接操作的segment。为了进一步的查询优化，Kafka又默认为分段后的数据文件建立了索引文件，就是文件系统上的.index文件。这种分区分段+索引的设计，不仅提升了数据读取的效率，同时也提高了数据操作的并行度。</p><h1 id="批量压缩"><a href="#批量压缩" class="headerlink" title="批量压缩"></a>批量压缩</h1><p>在很多情况下，系统的瓶颈不是CPU或磁盘，而是网络IO，对于需要在广域网上的数据中心之间发送消息的数据流水线尤其如此。进行数据压缩会消耗少量的CPU资源,不过对于kafka而言,网络IO更应该需要考虑。</p><p>如果每个消息都压缩，但是压缩率相对很低，所以Kafka使用了批量压缩，即将多个消息一起压缩而不是单个消息压缩</p><p>Kafka允许使用递归的消息集合，批量的消息可以通过压缩的形式传输并且在日志中也可以保持压缩格式，直到被消费者解压缩</p><p>Kafka支持多种压缩协议，包括Gzip和Snappy压缩协议</p><h1 id="为什么kafka比RocketMQ吞吐量更高"><a href="#为什么kafka比RocketMQ吞吐量更高" class="headerlink" title="为什么kafka比RocketMQ吞吐量更高"></a>为什么kafka比RocketMQ吞吐量更高</h1><p>kafka性吞吐量更高主要是由于Producer端将多个小消息合并，批量发向Broker。kafka采用异步发送的机制，当发送一条消息时，消息并没有发送到broker而是缓存起来，然后直接向业务返回成功，当缓存的消息达到一定数量时再批量发送。</p><p>此时减少了网络io，从而提高了消息发送的性能，但是如果消息发送者宕机，会导致消息丢失，业务出错，所以理论上kafka利用此机制提高了io性能却降低了可靠性。</p><h1 id="RocketMQ为何无法使用同样的方式"><a href="#RocketMQ为何无法使用同样的方式" class="headerlink" title="RocketMQ为何无法使用同样的方式"></a>RocketMQ为何无法使用同样的方式</h1><p>RocketMQ通常使用的Java语言，缓存过多消息会导致频繁GC。<br>Producer调用发送消息接口，消息未发送到Broker，向业务返回成功，此时Producer宕机，会导致消息丢失，业务出错。<br>Producer通常为分布式系统，且每台机器都是多线程发送，我们认为线上的系统单个Producer每秒产生的数据量有限，不可能上万。<br>缓存的功能完全可以由上层业务完成。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双重检测锁为什么要加Volatile</title>
    <link href="/2022/06/09/%E5%8F%8C%E9%87%8D%E6%A3%80%E6%B5%8B%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8A%A0Volatile/"/>
    <url>/2022/06/09/%E5%8F%8C%E9%87%8D%E6%A3%80%E6%B5%8B%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8A%A0Volatile/</url>
    
    <content type="html"><![CDATA[<h1 id="new一个实例"><a href="#new一个实例" class="headerlink" title="new一个实例"></a>new一个实例</h1>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单例模式</tag>
      
      <tag>volatile</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DNS用的是TCP还是UDP</title>
    <link href="/2022/06/08/DNS%E7%94%A8%E7%9A%84%E6%98%AFTCP%E8%BF%98%E6%98%AFUDP/"/>
    <url>/2022/06/08/DNS%E7%94%A8%E7%9A%84%E6%98%AFTCP%E8%BF%98%E6%98%AFUDP/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h1><p>UDP ：无连接，尽最大努力交付，首部一般8字节，占用资源少，一对多，传输的是用户数据报，速度快，主要用于视频，直播等。</p><p>TCP ：面向连接，可靠传输，首部大于20字节，占用资源较多，一对一，以字节流为传输单位，速度相对慢，主要用于邮件传输等。</p><h1 id="为什么DNS既使用TCP又使用UDP？"><a href="#为什么DNS既使用TCP又使用UDP？" class="headerlink" title="为什么DNS既使用TCP又使用UDP？"></a>为什么DNS既使用TCP又使用UDP？</h1><h2 id="DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议；"><a href="#DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议；" class="headerlink" title="DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议；"></a>DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议；</h2><p>DNS的规范规定了2种类型的DNS服务器，一个叫主DNS服务器，一个叫辅助DNS服务器。在一个区中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫做区传送（zone transfer）。</p><p>区域传输是DNS的事务，对准确性要求比较高，而且会产生大于512字节的数据包，因此使用TCP协议。</p><h2 id="为什么既使用TCP又使用UDP？"><a href="#为什么既使用TCP又使用UDP？" class="headerlink" title="为什么既使用TCP又使用UDP？"></a>为什么既使用TCP又使用UDP？</h2><p>首先了解一下TCP与UDP传送字节的长度限制。</p><p><em>UDP报文的最大长度为512字节，而TCP则允许报文长度超过512字节</em>。当DNS查询超过512字节时，协议的TC标志出现删除标志，这时则使用TCP发送。通常传统的UDP报文一般不会大于512字节。</p><h2 id="区域传送时使用TCP，主要有一下两点考虑"><a href="#区域传送时使用TCP，主要有一下两点考虑" class="headerlink" title="区域传送时使用TCP，主要有一下两点考虑"></a>区域传送时使用TCP，主要有一下两点考虑</h2><ol><li>辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。</li><li>TCP是一种可靠的连接，保证了数据的准确性。</li></ol><h2 id="域名解析时使用UDP协议"><a href="#域名解析时使用UDP协议" class="headerlink" title="域名解析时使用UDP协议"></a>域名解析时使用UDP协议</h2><p>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git使用指南</title>
    <link href="/2022/06/06/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2022/06/06/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="将本地项目上传到github"><a href="#将本地项目上传到github" class="headerlink" title="将本地项目上传到github"></a>将本地项目上传到github</h1><ol><li>github新建一个项目</li><li>在本地项目的根目录下打开gitbash</li><li>git初始化 <figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure></li><li>连接到远程仓库 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin 远程项目链接<br></code></pre></td></tr></table></figure></li><li>如果github上的远程项目有README.md这种本地没有的文件的话需要先pull合并一下 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull --rebase origin master<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBean创建流程分析</title>
    <link href="/2022/06/03/SpringBean%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <url>/2022/06/03/SpringBean%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>源码解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ReenteredLock源码解析</title>
    <link href="/2022/06/03/ReenteredLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/06/03/ReenteredLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Java多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码解析</tag>
      
      <tag>Java多线程</tag>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口限流原理到实践</title>
    <link href="/2022/06/03/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5/"/>
    <url>/2022/06/03/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="接口限流的4中方案"><a href="#接口限流的4中方案" class="headerlink" title="接口限流的4中方案"></a>接口限流的4中方案</h1><h2 id="固定窗口计数器"><a href="#固定窗口计数器" class="headerlink" title="固定窗口计数器"></a>固定窗口计数器</h2><ul><li>将时间划分为多个窗口</li><li>在每个窗口内每有一次请求就将计数器加一</li><li>如果计数器超过了限制数量，则本窗口内所有的请求都被丢弃当时间到达下一个窗口时，计数器重置。</li><li>固定窗口计数器是最为简单的算法，但这个算法有时会让通过请求量允许为限制的两倍。考虑如下情况：限制 1 秒内最多通过 5 个请求，在第一个窗口的最后半秒内通过了 5 个请求，第二个窗口的前半秒内又通过了 5 个请求。这样看来就是在 1 秒内通过了 10 个请求。</li></ul><h2 id="滑动窗口计数器"><a href="#滑动窗口计数器" class="headerlink" title="滑动窗口计数器"></a>滑动窗口计数器</h2><ul><li>将时间划分为多个区间；</li><li>在每个区间内每有一次请求就将计数器加一维持一个时间窗口，占据多个区间；</li><li>每经过一个区间的时间，则抛弃最老的一个区间，并纳入最新的一个区间；</li><li>如果当前窗口内区间的请求计数总和超过了限制数量，则本窗口内所有的请求都被丢弃。</li><li>滑动窗口计数器是通过将窗口再细分，并且按照时间 “ 滑动 “，这种算法避免了固定窗口计数器带来的双倍突发请求，但时间区间的精度越高，算法所需的空间容量就越大。</li></ul><h2 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h2><ul><li>将每个请求视作 “ 水滴 “ 放入 “ 漏桶 “ 进行存储；</li><li>漏桶算法多使用队列实现，服务的请求会存到队列中，服务的提供方则按照固定的速率从队列中取出请求并执行，过多的请求则放在队列中排队或直接拒绝。</li><li>漏桶算法的缺陷也很明显，当短时间内有大量的突发请求时，即便此时服务器没有任何负载，每个请求也都得在队列中等待一段时间才能被响应。</li></ul><h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><ul><li>令牌以固定速率生成。</li><li>生成的令牌放入令牌桶中存放，如果令牌桶满了则多余的令牌会直接丢弃，当请求到达时，会尝试从令牌桶中取令牌，取到了令牌的请求可以执行。</li><li>如果桶空了，那么尝试取令牌的请求会被直接丢弃。</li><li>令牌桶算法既能够将所有的请求平均分布到时间区间内，又能接受服务器能够承受范围内的突发请求，因此是目前使用较为广泛的一种限流算法。</li></ul><h1 id="使用令牌桶方法实现接口限流"><a href="#使用令牌桶方法实现接口限流" class="headerlink" title="使用令牌桶方法实现接口限流"></a>使用令牌桶方法实现接口限流</h1><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 每秒处理数（放入令牌数量）</span><br><span class="hljs-comment">    */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> putTokenRate;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 最后刷新时间</span><br><span class="hljs-comment">    */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> refreshTime;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 令牌桶容量</span><br><span class="hljs-comment">    */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> capacity;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 当前桶内令牌数</span><br><span class="hljs-comment">    */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">currentToken</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 漏桶算法</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">tokenBucketTryAcquire</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">currentTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();  <br>    <span class="hljs-type">long</span> <span class="hljs-variable">generateToken</span> <span class="hljs-operator">=</span> (currentTime - refreshTime) / <span class="hljs-number">1000</span> * putTokenRate; <br>    currentToken = Math.min(capacity, generateToken + currentToken); <br>    refreshTime = currentTime; <br>    <br>    <span class="hljs-keyword">if</span> (currentToken &gt; <span class="hljs-number">0</span>) &#123;<br>        currentToken--; <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal源码解析</title>
    <link href="/2022/05/29/ThreadLocal%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/05/29/ThreadLocal%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="基本使用和基础概念"><a href="#基本使用和基础概念" class="headerlink" title="基本使用和基础概念"></a>基本使用和基础概念</h1><h2 id="ThreadLocal有什么用"><a href="#ThreadLocal有什么用" class="headerlink" title="ThreadLocal有什么用"></a>ThreadLocal有什么用</h2><p>简单来说，ThreadLocal可以给线程保存变量，实现线程间隔离。</p><h2 id="简单使用ThreadLocal"><a href="#简单使用ThreadLocal" class="headerlink" title="简单使用ThreadLocal"></a>简单使用ThreadLocal</h2><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalTest</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;String&gt; threadLocal = ThreadLocal.withInitial(()-&gt;<span class="hljs-string">&quot;AAA&quot;</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                Thread.currentThread().setName(j + <span class="hljs-string">&quot;号线程&quot;</span>);<br><br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;的ThreadLocalMap : \n&quot;</span> +<br>                        threadLocal.hashCode() + <span class="hljs-string">&quot; : &quot;</span> + threadLocal.get() );<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br><br>                threadLocal.set(<span class="hljs-string">&quot;ABC&quot;</span> + j);<br><br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;的ThreadLocalMap : \n&quot;</span> +<br>                        threadLocal.hashCode() + <span class="hljs-string">&quot; : &quot;</span> + threadLocal.get() );<br>                threadLocal.remove();<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先定义了一个保存String类型变量的ThreadLocal，并且初始化为AAA。开启五个线程分别进行get、set，看看效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span>号线程的ThreadLocalMap : <br><span class="hljs-number">1288405787</span> : AAA<br><span class="hljs-number">0</span>号线程的ThreadLocalMap : <br><span class="hljs-number">1288405787</span> : ABC0<br><span class="hljs-number">1</span>号线程的ThreadLocalMap : <br><span class="hljs-number">1288405787</span> : AAA<br><span class="hljs-number">1</span>号线程的ThreadLocalMap : <br><span class="hljs-number">1288405787</span> : ABC1<br><span class="hljs-number">2</span>号线程的ThreadLocalMap : <br><span class="hljs-number">1288405787</span> : AAA<br><span class="hljs-number">2</span>号线程的ThreadLocalMap : <br><span class="hljs-number">1288405787</span> : ABC2<br><span class="hljs-number">3</span>号线程的ThreadLocalMap : <br><span class="hljs-number">1288405787</span> : AAA<br><span class="hljs-number">3</span>号线程的ThreadLocalMap : <br><span class="hljs-number">1288405787</span> : ABC3<br><span class="hljs-number">4</span>号线程的ThreadLocalMap : <br><span class="hljs-number">1288405787</span> : AAA<br><span class="hljs-number">4</span>号线程的ThreadLocalMap : <br><span class="hljs-number">1288405787</span> : ABC4<br></code></pre></td></tr></table></figure><p>可以看到前面的线程修改了ThreadLocal的值后，后面的线程一开始取到的还是最开始初始化的AAA，而不是前面线程修改后的值。也就是说ThreadLocal可以实现线程间隔离，<strong>即不同的线程对同一个ThreadLocal的操作是相互独立的。</strong></p><h2 id="ThreadLocal如何实现线程隔离"><a href="#ThreadLocal如何实现线程隔离" class="headerlink" title="ThreadLocal如何实现线程隔离"></a>ThreadLocal如何实现线程隔离</h2><h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><p>Thread类中有一个ThreadLocalMap字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    ......<br><br>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <br><span class="hljs-comment">//这个先不用管</span><br>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">inheritableThreadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>这个ThreadLocalMap又是啥呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocal</span>&lt;T&gt; &#123;<br><br>......<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalMap</span> &#123;<br><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>            Object value;<br><br>            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>                <span class="hljs-built_in">super</span>(k);<br>                value = v;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br><br>        <span class="hljs-keyword">private</span> Entry[] table;<br><br>        ......<br>    &#125;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>ThreadLocalMap中有一个Entry数组，Entry是ThreadLocal的<strong>弱引用</strong>，Entry内还有一个Object。这个ThreadLocalMap和HashMap很类似，可以简单理解为：ThreadLocal的弱引用为Key，Object为Value。这样可以实现 ThreadLocal 和 Object 的一一对应。</p><p>看到这里，你一定会有诸多疑惑：</p><ol><li>为什么是操作ThreadLocal而不是直接操作Thread呢?</li><li>不同线程都操作同一个ThreadLocal怎么就能实现线程间隔离的效果呢？</li><li>为什么这个ThreadLocalMap要定义在ThreadLocal类的内部呢，为什么不定义在Thread类的内部呢？</li><li>……</li></ol><p>不要着急，我们接着往下看，打开ThreadLocal的源码，可以看到里面的get，set等方法，让我们看看它是怎么实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocal</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">threadLocalHashCode</span> <span class="hljs-operator">=</span> nextHashCode();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">nextHashCode</span> <span class="hljs-operator">=</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">HASH_INCREMENT</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x61c88647</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextHashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);<br>    &#125;<br><br>    ......<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>        ......<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>        ......<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>        ......<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> getMap(Thread.currentThread());<br>        <span class="hljs-keyword">if</span> (m != <span class="hljs-literal">null</span>)<br>            m.remove(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>        <span class="hljs-keyword">return</span> t.threadLocals;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>ThreadLocal在每次进行get、set等操作的时候，都会先获取到当前的线程，然后获取到线程内的ThreadLocalMap，而这个ThreadLocalMap里面存储的就是ThreadLocal和Object的映射，通过ThreadLocal获取对应的Object，因为ThreadLocalMap在每个Thread的内部，每个线程内的ThreadLocalMap都是不一样的，这样就达到了线程隔离的效果。</p><p>也就是说，<strong>在实际使用过程中，调用ThreadLocal对象的get、set方法时，会先去找到当前的线程内的ThreadLocalMap，再去进行相应的操作。这样ThreadLocal就能实现给线程保存变量，达到线程间隔离的效果</strong></p><p><strong>ThreadLocal本身是作为一个key来让线程从ThreadLocalMap获取value</strong>。 </p><h1 id="源码详解"><a href="#源码详解" class="headerlink" title="源码详解"></a>源码详解</h1><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><h3 id="ThreadLocal哈希值的计算"><a href="#ThreadLocal哈希值的计算" class="headerlink" title="ThreadLocal哈希值的计算"></a>ThreadLocal哈希值的计算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocal</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">threadLocalHashCode</span> <span class="hljs-operator">=</span> nextHashCode();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">nextHashCode</span> <span class="hljs-operator">=</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">HASH_INCREMENT</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x61c88647</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextHashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>threadLocalHashCode被声明为final，说明是个常量，每个ThreadLocal对象生成的时候，它们的threadLocalHashCode就不会再变了。</li><li>threadLocalHashCode通过nextHashCode()方法生成，nextHashCode()方法通过将nextHashCode变量 + HASH_INCREMENT 得到新的hash值（这里方法名和字段名一样，不要搞混）</li><li>nextHashCode变量被声明为static，说明是所有ThreadLocal对象共用的，也就是说会有并发问题，所以这里设计成了AtomicInteger原子类，它的getAndAdd方法是原子性的。</li></ul><h3 id="魔数0x61c88647"><a href="#魔数0x61c88647" class="headerlink" title="魔数0x61c88647"></a>魔数0x61c88647</h3><p>思考一个问题：每次+0x61c88647 这种生成hash值的方法有什么好处呢？</p><p>这个值很特殊，它是<strong>斐波那契数</strong>也叫<strong>黄金分割数</strong>。hash增量为这个数字，带来的好处就是hash分布非常均匀。</p><p>引用别人的一组数据：</p><blockquote><p>(take 16 (magic-hash 16))<br>(0 7 14 5 12 3 10 1 8 15 6 13 4 11 2 9)</p><p>(take 32 (magic-hash 32))<br>(0 7 14 21 28 3 10 17 24 31 6 13 20 27 2 9 16 23 30 5 12 19 26 1 8 15 22 29 4 11 18 25)</p><p>(take 64 (magic-hash 64))<br>(0 7 14 21 28 35 42 49 56 63 6 13 20 27 34 41 48 55 62 5 12 19 26 33 40 47 54 61 4 11 18 25 32 39 46 53 60 3 10 17 24 31 38 45 52 59 2 9 16 23 30 37 44 51 58 1 8 15 22 29 36 43 50 57)</p></blockquote><p>确实是非常均匀！相关原理这里就不在深究了，想深入学习的可以查阅其他相关的资料。</p><h3 id="ThreadLocalMap的哈希算法"><a href="#ThreadLocalMap的哈希算法" class="headerlink" title="ThreadLocalMap的哈希算法"></a>ThreadLocalMap的哈希算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>ThreadLocalMap通过 <strong>hash值 &amp; (len-1)</strong> 来计算对应的位置，因为len的值是 2的n次方，所以hash&amp;(len-1)相当于对hash%len。（不理解的可以在草稿纸上手算算，就懂了）</p><h2 id="ThreadLocalMap-1"><a href="#ThreadLocalMap-1" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><h3 id="基本数据结构Entry"><a href="#基本数据结构Entry" class="headerlink" title="基本数据结构Entry"></a>基本数据结构Entry</h3><p>ThreadLocalMap内部存储的是Entry数组，每个Entry是ThreadLocal<strong>弱引用</strong>和Object的映射，和HashMap很类似。</p><p><strong>当发生GC的时候，如果一个对象只存在弱引用，那么它会被清理掉。</strong></p><p>所以Entry会存在引用为null，但是value还在的情况，但由于引用为null，所以这个value实际上永远都不会被访问到了，这就引发了内存泄漏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>    <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>    Object value;<br><br>    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>        <span class="hljs-built_in">super</span>(k);<br>        value = v;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> Entry[] table;<br></code></pre></td></tr></table></figure><h3 id="nextIndex与preIndex"><a href="#nextIndex与preIndex" class="headerlink" title="nextIndex与preIndex"></a>nextIndex与preIndex</h3><p>获取下一个位置和上一个位置的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> len)</span> &#123;<br><span class="hljs-keyword">return</span> ((i + <span class="hljs-number">1</span> &lt; len) ? i + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">prevIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> len)</span> &#123;<br><span class="hljs-keyword">return</span> ((i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) ? i - <span class="hljs-number">1</span> : len - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="初始容量"><a href="#初始容量" class="headerlink" title="初始容量"></a>初始容量</h3><p>ThreadLocalMap的初始容量为16</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br></code></pre></td></tr></table></figure><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><ul><li>当剩余容量不足1&#x2F;3时，会触发扩容</li><li>每次扩容都将当前容量*2，保证容量一直都是2的n次方</li><li>扩容后要将table（即Entry数组）内的元素rehash到正确的位置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//The number of entries in the table.</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//The next size value at which to resize.</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> threshold; <span class="hljs-comment">// Default to 0</span><br><br><span class="hljs-comment">// Set the resize threshold to maintain at worst a 2/3 load factor.</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setThreshold</span><span class="hljs-params">(<span class="hljs-type">int</span> len)</span> &#123;<br>    threshold = len * <span class="hljs-number">2</span> / <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">()</span> &#123;<br>    Entry[] oldTab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldLen</span> <span class="hljs-operator">=</span> oldTab.length;<br>    <span class="hljs-comment">//新容量为就容量*2</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">newLen</span> <span class="hljs-operator">=</span> oldLen * <span class="hljs-number">2</span>;<br>    Entry[] newTab = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[newLen];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldLen; ++j) &#123;<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> oldTab[j];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            ThreadLocal&lt;?&gt; k = e.get();<br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//k == null 说明引用的ThreadLocal被GC了</span><br>                <span class="hljs-comment">//防止内存泄漏</span><br>                e.value = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Help the GC</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> k.threadLocalHashCode &amp; (newLen - <span class="hljs-number">1</span>);<br>                <span class="hljs-comment">//如果发生hash冲突，就放到h后面第一个空的位置(为什么这么做后面再分析)</span><br>                <span class="hljs-keyword">while</span> (newTab[h] != <span class="hljs-literal">null</span>)<br>                    h = nextIndex(h, newLen);<br>                newTab[h] = e;<br>                count++;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    setThreshold(newLen);<br>    size = count;<br>    table = newTab;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="发生Hash冲突怎么办"><a href="#发生Hash冲突怎么办" class="headerlink" title="发生Hash冲突怎么办"></a>发生Hash冲突怎么办</h3><p>与HashMap不同的是，ThreadLocalMap在发生hash冲突的时候，并没有将entry升级为链，而是采用线性探测法：向后找到第一个能放的位置放。</p><p><strong>因为ThreadLocal采用的hash方式，会使得分布非常均匀</strong>，这样线性探测没多久就能找到空的位置。</p><h3 id="ThreadLocalMap-set"><a href="#ThreadLocalMap-set" class="headerlink" title="ThreadLocalMap.set()"></a>ThreadLocalMap.set()</h3><p>当向ThreadLocalMap中set数据的时候，首先会获取到Key对应的位置i。</p><ul><li>i位置为空<ul><li>退出for循环</li></ul></li><li>i位置不为空，则向后探测（i &#x3D; nextIndex(i, len)）<ul><li>i位置为空，退出for循环</li><li>找到一个Entry的key 等于 要set的key，更新value，<strong>return</strong></li><li>找到一个Key为null，说明该key已经过期（引用的ThreadLocal被清理了），执行replaceStaleEntry，<strong>return</strong></li></ul></li></ul><p>当遇到i位置为空，退出for循环后，会执行**tab[i] &#x3D; new Entry(key, value)**，封装一个Entry放进空的位置。</p><p>然后进行启发式清理（cleanSomeSlots），如果启发式清理没清理掉东西，并且sz &gt;&#x3D; threshold，就会执行rehash()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;<br>    <br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>         e != <span class="hljs-literal">null</span>;<br>         e = tab[i = nextIndex(i, len)]) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br><br>        <span class="hljs-keyword">if</span> (k == key) &#123;<br>            e.value = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>            replaceStaleEntry(key, value, i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    tab[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> ++size;<br>    <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>        rehash();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="replaceStaleEntry"><a href="#replaceStaleEntry" class="headerlink" title="replaceStaleEntry"></a>replaceStaleEntry</h4><p>这个函数是在Key&#x3D;&#x3D;null的时候才进入的，也就是说执行这个函数的时候，一定是有一些key失效的，那么在set值的时候，也要进行垃圾清理，在进行垃圾检测的时候，并不是检测所有的Entry，而是检测staleSlot位置所在的那一段非空Entry中是不是有过期key。</p><p>先解释下这个函数里的一些变量的含义：</p><p>​staleSlot：该位置的key是过期的，同时也是新Entry要放的位置</p><p>​slotToExpunge：垃圾清理开始的位置</p><p>​<strong>注意：staleSlot位置放了新Entry之后就不是过期的了，也就是说如果最后slotToExpunge &#x3D;&#x3D; staleSlot，就不需要进行垃圾清理。</strong></p><p>文字版执行流程（也可以直接看源码，上面也写了注释）：</p><ul><li><p>首先从staleSlot位置向前探测，找到staleSlot左侧<strong>连续的非空Entry</strong>中<strong>最左边</strong>的过期key的位置，标记为slotToExpunge。</p></li><li><p>然后从staleSlot位置向后探测，找后面的<strong>连续的非空Entry</strong>中是否有k 等于 key</p><ul><li>如果相等的话，就和staleSlote位置的Entry交换，并且进行垃圾清理，<strong>return</strong>。</li><li>如果有位置k是过期的，并且staleSlot左边没有过期key（slotToExpunge &#x3D;&#x3D; staleSlot），就将slotToExpunge设为当前的位置</li></ul></li><li><p>接着将staleSlot位置的value清空，放入新的Entry（tab[staleSlot] &#x3D; new Entry(key, value)）（如果能走到这一步，说明staleSlot位置右边的Entry中没有k和key相等）</p></li><li><p>最后判断slotToExpunge如果不等于staleSlot，说明存在一些key失效，就需要进行垃圾清理（启发式清理+探测式清理），防止内存泄漏。</p></li></ul><p><strong>注：之所以要向后找，是因为在set时如果发生hash冲突，会将Entry放在右边第一个空的位置，所以需要向后探测，看看这个key是不是已经放过了，只不过因为hash冲突，放在了后面。同理，在get的时候，如果hashcode&amp;（len-1）位置不是对应的key，也要向后找。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">replaceStaleEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value,</span><br><span class="hljs-params">                               <span class="hljs-type">int</span> staleSlot)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    Entry e;<br><span class="hljs-comment">//从staleSlot位置向前探测，找到staleSlot左侧连续的非空Entry中最左边的过期key的位置，标记为slotToExpunge。</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">slotToExpunge</span> <span class="hljs-operator">=</span> staleSlot;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> prevIndex(staleSlot, len);<br>         (e = tab[i]) != <span class="hljs-literal">null</span>;<br>         i = prevIndex(i, len))<br>        <span class="hljs-keyword">if</span> (e.get() == <span class="hljs-literal">null</span>)<br>            slotToExpunge = i;<br><span class="hljs-comment">//遍历staleSlote后面的非空Entry</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nextIndex(staleSlot, len);<br>         (e = tab[i]) != <span class="hljs-literal">null</span>;<br>         i = nextIndex(i, len)) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br><br>        <span class="hljs-comment">//如果找到key，就要和staleSlote位置的Entry交换</span><br>        <span class="hljs-keyword">if</span> (k == key) &#123;<br>            e.value = value;<br><br>            tab[i] = tab[staleSlot];<br>            tab[staleSlot] = e;<br>            <span class="hljs-comment">//staleSlot位置的Key不再是过期的了，所以slotToExpunge如果等于staleSlot，就要更新成i</span><br>            <span class="hljs-keyword">if</span> (slotToExpunge == staleSlot)<br>                slotToExpunge = i;<br>            <span class="hljs-comment">//垃圾清理</span><br>            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><span class="hljs-comment">//更新slotToExpunge</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span> &amp;&amp; slotToExpunge == staleSlot)<br>            slotToExpunge = i;<br>    &#125;<br><br>    <span class="hljs-comment">// staleSlot位置放入新的Entry</span><br>    tab[staleSlot].value = <span class="hljs-literal">null</span>;<br>    tab[staleSlot] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);<br><br>    <span class="hljs-comment">// 如果slotToExpunge == staleSlot 说明没有需要清理的过期key，不需要进行垃圾清理。</span><br>    <span class="hljs-keyword">if</span> (slotToExpunge != staleSlot)<br>        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="过期Key的清理"><a href="#过期Key的清理" class="headerlink" title="过期Key的清理"></a>过期Key的清理</h4><h5 id="探测式清理（expungeStaleEntry）"><a href="#探测式清理（expungeStaleEntry）" class="headerlink" title="探测式清理（expungeStaleEntry）"></a>探测式清理（expungeStaleEntry）</h5><p>探测式清理主要做两个工作：</p><ol><li>清理staleSlot所在的那一段<strong>连续的不为null的Entry</strong>中key过期的Entry</li><li>因为清理会空出来一些位置，所以之前set的时候因为hash冲突，会有些key并不在hash &amp; (len-1) 的位置上，所以需要重新计算位置。这样做的目的是尽可能的让key的位置接近hash &amp; (len-1)，在get，set的时候效率会更高一些。</li></ol><p>expungeStaleEntry函数返回的是staleStole右边第一个Entry为null的位置，这个值在启发式清理里会用到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">expungeStaleEntry</span><span class="hljs-params">(<span class="hljs-type">int</span> staleSlot)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br><br>    <span class="hljs-comment">// 清空staleSlot位置的entry</span><br>    tab[staleSlot].value = <span class="hljs-literal">null</span>;<br>    tab[staleSlot] = <span class="hljs-literal">null</span>;<br>    size--;<br><br>    <span class="hljs-comment">// 当遇到key为null时rehash</span><br>    Entry e;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = nextIndex(staleSlot, len);<br>         (e = tab[i]) != <span class="hljs-literal">null</span>;<br>         i = nextIndex(i, len)) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>            e.value = <span class="hljs-literal">null</span>;<br>            tab[i] = <span class="hljs-literal">null</span>;<br>            size--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> k.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (h != i) &#123;<br>                tab[i] = <span class="hljs-literal">null</span>;<br>                <span class="hljs-comment">//找到离h最近的位置放，最坏的情况是仍然放在i位置</span><br>                <span class="hljs-keyword">while</span> (tab[h] != <span class="hljs-literal">null</span>)<br>                    h = nextIndex(h, len);<br>                tab[h] = e;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//这时候tab[i] = null</span><br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="启发式清理（cleanSomeSlots）"><a href="#启发式清理（cleanSomeSlots）" class="headerlink" title="启发式清理（cleanSomeSlots）"></a>启发式清理（cleanSomeSlots）</h5><p>启发式清理就是从i位置开始向后遍历log(n)次，如果遇到过期的key，就进行探测式清理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cleanSomeSlots</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-keyword">do</span> &#123;<br>        i = nextIndex(i, len);<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == <span class="hljs-literal">null</span>) &#123;<br>            n = len;<br>            removed = <span class="hljs-literal">true</span>;<br>            i = expungeStaleEntry(i);<br>        &#125;<br>        <span class="hljs-comment">//n&gt;&gt;&gt;=1 每次会将n右移一位，一共会右移logn次</span><br>    &#125; <span class="hljs-keyword">while</span> ( (n &gt;&gt;&gt;= <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> removed;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：探测式清理和启发式清理都不能保证完全清理整个table中的所有过期key，只能清理局部的过期key</strong></p><h4 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h4><p>rehash会先对table（Entry数组）进行一次全面的垃圾清理（expungeStaleEntries）,然后如果size &gt;&#x3D; threshold - threshold &#x2F; 4则进行扩容。</p><p>因为threshold&#x3D;len * 2&#x2F;3,所以相当于size &gt;&#x3D; len * 1&#x2F;2。</p><p>至于为什么是 size &gt;&#x3D; threshold * 3&#x2F;4 官方是这么解释的：</p><blockquote><p>Use lower threshold for doubling to avoid hysteresis</p><p>使用较低的阈值来避免滞后。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rehash</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//进行全面的垃圾清理</span><br>    expungeStaleEntries();<br>    <span class="hljs-comment">//size &gt;= threshold * 3/4 = len * 1/2</span><br>    <span class="hljs-keyword">if</span> (size &gt;= threshold - threshold / <span class="hljs-number">4</span>)<br>        resize();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">expungeStaleEntries</span><span class="hljs-params">()</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; len; j++) &#123;<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[j];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == <span class="hljs-literal">null</span>)<br>            expungeStaleEntry(j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ThreadLocalMap-getEntry"><a href="#ThreadLocalMap-getEntry" class="headerlink" title="ThreadLocalMap.getEntry()"></a>ThreadLocalMap.getEntry()</h3><p>getEntry方法返回key对应的Entry</p><p>如果i位置没找到对应的key，就向后找，如果遇到失效key，就执行垃圾清理。最后如果没找到就返回null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> table[i];<br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == key)<br>        <span class="hljs-keyword">return</span> e;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">//e == null || e.get() != key</span><br>        <span class="hljs-keyword">return</span> getEntryAfterMiss(key, i, e);<br>&#125;<br><br><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntryAfterMiss</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, <span class="hljs-type">int</span> i, Entry e)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br><br>    <span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span>) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-keyword">if</span> (k == key)<br>            <span class="hljs-keyword">return</span> e;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>)<br>            expungeStaleEntry(i);<br>        <span class="hljs-keyword">else</span><br>            i = nextIndex(i, len);<br>        e = tab[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ThreadLocalMap-remove"><a href="#ThreadLocalMap-remove" class="headerlink" title="ThreadLocalMap.remove()"></a>ThreadLocalMap.remove()</h3><p>删除某个key对应的entry</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>         e != <span class="hljs-literal">null</span>;<br>         e = tab[i = nextIndex(i, len)]) &#123;<br>        <span class="hljs-keyword">if</span> (e.get() == key) &#123;<br>            <span class="hljs-comment">//将e的引用设为null</span><br>            e.clear();<br>            <span class="hljs-comment">//垃圾清理的时候会将table[i]清理掉</span><br>            expungeStaleEntry(i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ThreadLocal-set"><a href="#ThreadLocal-set" class="headerlink" title="ThreadLocal.set()"></a>ThreadLocal.set()</h2><p>取到当前线程的ThreadLocalMap，调用ThreadLocalMap.set()方法插入值，该方法前面已经分析过了，这里就不再赘述了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>    map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>    createMap(t, value);<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>    t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ThreadLocal-get"><a href="#ThreadLocal-get" class="headerlink" title="ThreadLocal.get()"></a>ThreadLocal.get()</h2><p>取到当前线程的ThreadLocalMap，再调用ThreadLocalMap.getEntry()方法得到Entry。如果得到的是map为nul或者e为null时，就调用ThreadLocal.setInitialValue()方法，如果为这个ThreadLocal设置过初始值的话，就会设置value为初始值，并返回。</p><p>ThreadLocal.setInitialValue() 和 ThreadLocal.set() 基本一样，这里也就不再赘述了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//找到当前的线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">//获取ThreadLocalMap</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//map不为null,则获取对应的Entry </span><br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//返回该Entry里的Object</span><br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//当map为null 或者 e为null时,需要执行这一步 </span><br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br><br><span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-comment">//如果map不为null，就将initialVal设置成对应的Object，插入map。</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-comment">//如果map为null，为t线程创建ThreadLocalMap,并初始化</span><br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><span class="hljs-comment">//如果不指定的话，初始值就是null</span><br><span class="hljs-keyword">protected</span> T <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="为ThreadLocal设置初始值"><a href="#为ThreadLocal设置初始值" class="headerlink" title="为ThreadLocal设置初始值"></a>为ThreadLocal设置初始值</h2><p>可以通过 <strong>ThreadLocal.withInitial(…)</strong> 来为ThreadLocal设置初始值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; ThreadLocal&lt;S&gt; <span class="hljs-title function_">withInitial</span><span class="hljs-params">(Supplier&lt;? extends S&gt; supplier)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuppliedThreadLocal</span>&lt;&gt;(supplier);<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SuppliedThreadLocal</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadLocal</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Supplier&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>&gt; supplier;<br><br>    SuppliedThreadLocal(Supplier&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>&gt; supplier) &#123;<br>        <span class="hljs-built_in">this</span>.supplier = Objects.requireNonNull(supplier);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> T <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> supplier.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到SuppliedThreadLocal继承了ThreadLocal，实现了它的initialValue方法，return的是supplier.get()</p><p>那么这个Supplier是啥呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Supplier</span>&lt;T&gt; &#123;<br>    T <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实就是一个函数式接口，实现它的get方法返回你要的东西，也就是我们需要的初始值。</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="ThreadLocal中的AtomicInteger为什么是private"><a href="#ThreadLocal中的AtomicInteger为什么是private" class="headerlink" title="ThreadLocal中的AtomicInteger为什么是private"></a>ThreadLocal中的AtomicInteger为什么是private</h2><p>如果不是private的话，每新建一个ThreadLocal对象都会生成新的AtomicInteger，这样算出的hashcode就不对了。</p><h2 id="ThreadLocalMap为什么设计为ThreadLocal的内部类"><a href="#ThreadLocalMap为什么设计为ThreadLocal的内部类" class="headerlink" title="ThreadLocalMap为什么设计为ThreadLocal的内部类"></a>ThreadLocalMap为什么设计为ThreadLocal的内部类</h2><ul><li>ThreadLocalMap在Thread中默认为null</li><li>操作ThreadLocal的时候会检查线程中的ThreadLocalMap是否为null，如果为null就新建一个。</li><li>这样做的好处是可以实现ThreadLocalMap的按需加载，不会浪费资源。</li><li>如果设计在Thread内，那么在new Thread的时候就要创建出ThreadLocalMap，但如果用不到的话，就会浪费资源。</li></ul><h2 id="Entry为什么是弱引用WearReference"><a href="#Entry为什么是弱引用WearReference" class="headerlink" title="Entry为什么是弱引用WearReference"></a>Entry为什么是弱引用WearReference</h2><p>首先，弱引用增加了ThreadLocal的复杂度—-在get、set的时候都要判断key是否为null，还要考虑过期key的清理，还有可能造成内存泄露的问题。还需要考虑要用的value的key被GC了的情况，那么为什么要这么设计呢？</p><p>我认为：</p><ul><li><p>如果是强引用就会形成这么个引用链：Thread-&gt;ThreadLocalMap-&gt;Entry-&gt;[ThreadLocal,Value]，那么如果使用者用完不<strong>手动将Entry设为null</strong>（设为null的话GC的时候通过可达性分析是可以清理掉ThreadLocal的）的话，在使用ThreadLoal的线程全部结束前，ThreadLocal对象是一直存在的。</p></li><li><p>如果使用者粗心大意，没有在用完后将Entry设为null，那么可能会造成严重的内存泄漏（引用的ThreadLocal和value后面不再需要，白白占用内存空间），<strong>且只会比弱引用更严重</strong>，并且<strong>难以修复</strong>（因为都是强引用，GC的时候不会清理掉）</p></li><li><p>为了避免使用者的粗心，所以设计人员才将Entry设置为弱引用，在get、set、扩容等操作时，都会进行失效key的清理，虽然一定程度上增加了复杂度，损失了一点性能，但能很大程度上避免内存泄漏。</p></li><li><p>同时，在使用ThreadLocal的时候，我们一般也要在用完后进行**手动的remove()**，这样其实即使是弱引用，也不用担心会发生内存泄漏。</p></li><li><p>分析到这里我们也发现了：不管是弱引用还是强引用都要<strong>手动释放引用</strong>。</p><p>但如果使用者忘了，如果是弱引用的话，可以通过在get、set、扩容等方法中穿插清理失效key，这能在很大程度上减缓内存泄漏带来的影响。但如果是强引用的话，就没啥好的办法了（也许只能在jvm的堆快满了的时候进行full gc才会清理调它们），极端情况下，可能会对系统造成严重的影响。   </p><p>但如果使用者有及时释放的好习惯的话，在get、set、扩容等方法中寻找到key&#x3D;&#x3D;null的情况就很少了，算下来其实也不会浪费多少性能。</p></li></ul><h2 id="ThreadLocal为什么需要定义成static"><a href="#ThreadLocal为什么需要定义成static" class="headerlink" title="ThreadLocal为什么需要定义成static"></a>ThreadLocal为什么需要定义成static</h2><p>ThreadLocal 类的目的是为每个线程单独维护一个变量的值，避免线程间对同一变量的竞争访问，适用于一个变量在每个线程中需要有自己独立的值的场合。</p><p>如果把 ThreadLocal 声明为非静态，则在含有 ThreadLocal 变量的的每个实例中都会产生一个新对象，这就起不到对应的效果了（通过一个ThreadLocal在不同的线程中获取不同的值）。</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>在访问不到的数据被回收之前，内存泄漏确实是存在的，但是在进行get、set、扩容等操作时，都会检查失效key的清理，一般在使用的时候，用完要手动remove，所以，内存泄漏完全没必要过于担心。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="用户信息保存"><a href="#用户信息保存" class="headerlink" title="用户信息保存"></a>用户信息保存</h2><p>这是我在面试阿里的时候遇到的面试题，题目大致是这样的：</p><p><strong>controller层在处理用户请求的时候，如果方法里面不写参数，怎么知道当前的用户是谁。</strong></p><p>解答：在前后端分离的项目中（现在绝大多数都是前后端分离），用户登录后，用户信息会保存在Session或者Token中。当我们需要用户信息的时候，拿Session来说，我们可以在接口参数中加上HttpServletRequest，调用 getSession方法获取信息，但是如果且每一个需要用户信息的接口都要加上这个参数，才能获取Session，这样实现就比较麻烦。</p><p>在实际的系统设计中，一般都会在拦截器中使用ThreadLocal，保存用户信息。那么当前线程在任何地方如果需要拿到用户信息都可以使用ThreadLocal的get()方法 。</p><h2 id="Spring-单例模式下的线程安全问题"><a href="#Spring-单例模式下的线程安全问题" class="headerlink" title="Spring 单例模式下的线程安全问题"></a>Spring 单例模式下的线程安全问题</h2><p>在Spring的Web项目中,Dao层一般都是单例，但spring的单例指的是在Bean容器中只有一个对象，它并不能保证线程安全。当多线程线程请求打上来的时候，因为负责数据库连接的Connection只有一个，如果每个请求线程都去连接数据库，就会造成线程不安全的问题。</p><p>Spring的解决方案就是采用ThreadLocal方法，当每个请求线程使用Connection的时候， 都会从ThreadLocal获取一次，如果为null，说明没有进行过数据库连接，连接后存入ThreadLocal中，如此一来，每一个请求线程都保存有一份自己的Connection。于是便解决了线程安全问题</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://juejin.cn/post/6844903648800014349#heading-5">为什么使用0x61c88647</a></p><p><a href="https://juejin.cn/post/6844904146127044622">万字图文深度解析ThreadLocal</a></p><p><a href="https://www.modb.pro/db/194154">为什么ThreadLocal容易导致内存泄漏？</a></p><p><a href="https://zhuanlan.zhihu.com/p/489079713">一文读懂ThreadLocal</a></p>]]></content>
    
    
    <categories>
      
      <category>Java多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ThreadLocal</tag>
      
      <tag>Java多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ClassCastException之同类型bean无法进行类型转换的问题</title>
    <link href="/2022/05/12/%E5%90%8C%E7%B1%BB%E5%9E%8Bbean%E6%97%A0%E6%B3%95%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2022/05/12/%E5%90%8C%E7%B1%BB%E5%9E%8Bbean%E6%97%A0%E6%B3%95%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在进行微信公众号开发的时候，需要把接收的xml转换成bean，用到了Xstream类型转换框架。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">xmlToBean</span><span class="hljs-params">(String resultXml, Class clazz)</span> &#123;<br>    <span class="hljs-type">XStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DomDriver</span>());<br>    XStream.setupDefaultSecurity(stream);<br>    stream.allowTypes(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;clazz&#125;);<br>    stream.processAnnotations(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;clazz&#125;);<br>    stream.setMode(XStream.NO_REFERENCES);<br>    stream.alias(<span class="hljs-string">&quot;xml&quot;</span>, clazz);<br>    <span class="hljs-keyword">return</span> (T) stream.fromXML(resultXml);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">MessageTextEntity</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> XmlUtil.xmlToBean(requestBody, MessageTextEntity.class);<br></code></pre></td></tr></table></figure><p>可以看到这里需要进行一个同类型的转换，但是出现了以下报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">java.lang.ClassCastException: com.ljf.ploughthewaves.domain.wx.model.MessageTextEntity cannot be cast to com.ljf.ploughthewaves.domain.wx.model.MessageTextEntity<br>at com.ljf.ploughthewaves.interfaces.WxPortalController.post(WxPortalController.java:<span class="hljs-number">75</span>) ~[classes/:na]<br>at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:<span class="hljs-number">1.8</span><span class="hljs-number">.0_311</span>]<br>at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="hljs-number">62</span>) ~[na:<span class="hljs-number">1.8</span><span class="hljs-number">.0_311</span>]<br>at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="hljs-number">43</span>) ~[na:<span class="hljs-number">1.8</span><span class="hljs-number">.0_311</span>]<br>at java.lang.reflect.Method.invoke(Method.java:<span class="hljs-number">498</span>) ~[na:<span class="hljs-number">1.8</span><span class="hljs-number">.0_311</span>]<br>at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:<span class="hljs-number">205</span>) [spring-web-<span class="hljs-number">5.3</span><span class="hljs-number">.13</span>.jar:<span class="hljs-number">5.3</span><span class="hljs-number">.13</span>]<br>at ......<br><br></code></pre></td></tr></table></figure><p>可以注意到这是<strong>同类型bean</strong>转换出错。</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>写了个测试类模拟了一下，发现在测试类中竟然无法复现这个问题……</p><p>那么问题一定就出在业务代码中，回顾一下Java是如何判断两个类相等的：</p><p><strong>类的全限定名+类的加载器</strong></p><p>试着在代码中打印一下每一步的类加载器发现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">类加载器<span class="hljs-number">1</span>: org.springframework.boot.devtools.restart.classloader.RestartClassLoader@53a644b8<br>类加载器<span class="hljs-number">2</span>：org.springframework.boot.devtools.restart.classloader.RestartClassLoader@53a644b8<br>类加载器<span class="hljs-number">3</span>：sun.misc.Launcher$AppClassLoader@18b4aac2<br></code></pre></td></tr></table></figure><p><strong>xmltobean方法生成的对象的类加载器和需要转换的bean的类加载器不一样</strong>，所以导致了类不能转换。</p><p>可以看到bean的类加载器被devtools替换成了它自己的类加载器。</p><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>禁用spring-boot-devtools 或者把restart属性设置为false</p>]]></content>
    
    
    <categories>
      
      <category>Bugs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bugs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL更新语句的执行流程</title>
    <link href="/2022/05/09/SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    <url>/2022/05/09/SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>执行一条“增删改”语句的时候，虽然没有输入 begin 开启事务和 commit 提交事务，但是 MySQL 会<strong>隐式开启事务</strong>来执行“增删改”语句的，执行完就自动提交事务的。</p><p>当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做 </p><h1 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h1><p><code>redo log</code> 是物理日志，记录了某个数据页做了什么修改，对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新，每当执行一个事务就会产生这样的一条物理日志。</p><p> 为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，<code>InnoDB</code> 引擎就会先把记录写到 <code>redo log</code> 里面，并更新内存，这个时候更新就算完成了。同时，<code>InnoDB</code> 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里 </p><p>在事务提交时，只要先将 <code>redo log</code> 持久化到磁盘即可，可以不需要将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。当系统崩溃时，虽然脏页数据没有持久化，但是 <code>redo log</code> 已经持久化，接着 MySQL 重启后，可以根据 <code>redo log</code> 的内容，将所有数据恢复到最新的状态。</p><h2 id="刷盘时机"><a href="#刷盘时机" class="headerlink" title="刷盘时机"></a>刷盘时机</h2><p><code>InnoDB</code> 存储引擎为 <code>redo log</code> 的刷盘策略提供了 <code>innodb_flush_log_at_trx_commit</code> 参数，它支持三种策略：</p><ul><li><strong>0</strong> ：设置为 0 的时候，表示每次事务提交时不进行刷盘操作</li><li><strong>1</strong> ：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）</li><li><strong>2</strong> ：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache</li></ul><p><code>innodb_flush_log_at_trx_commit</code> 参数默认为 1 ，也就是说当事务提交时会调用 <code>fsync</code> 对 <code>redo log</code> 进行刷盘</p><p>另外，<code>InnoDB</code> 存储引擎有一个后台线程，每隔<code>1</code> 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存（<code>page cache</code>），然后调用 <code>fsync</code> 刷盘。</p><h1 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h1><h2 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h2><p><code>binlog</code> 日志有三种格式，可以通过<code>binlog_format</code>参数指定。</p><ul><li><p><strong>statement</strong></p><p> 每一条修改数据的 SQL 都会被记录到 <code>binlog</code> 中（相当于记录了逻辑操作，所以针对这种格式， <code>binlog</code> 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。但 STATEMENT 有动态函数的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致； </p></li><li><p><strong>row</strong></p><p>记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已； </p></li><li><p><strong>mixed</strong></p><p> 包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式；</p></li></ul><h2 id="刷盘时机-1"><a href="#刷盘时机-1" class="headerlink" title="刷盘时机"></a>刷盘时机</h2><p> 事务执行过程中，先把日志写到 <code>binlog cache</code>（Server 层的 cache），事务提交的时候，再把 <code>binlog cache</code> 写到 <code>binlog</code> 文件中。 </p><p>MySQL提供一个 <code>sync_binlog</code> 参数来控制数据库的 <code>binlog</code> 刷到磁盘上的频率：</p><ul><li><p>sync_binlog &#x3D; 0 </p><p>每次提交事务都只 write，不 fsync，后续交由操作系统决定何时将数据持久化到磁盘；</p></li><li><p>sync_binlog &#x3D; 1 </p><p>每次提交事务都会 write，然后马上执行 fsync；</p></li><li><p>sync_binlog &#x3D;N(N&gt;1) 的时候</p><p>每次提交事务都 write，但累积 N 个事务后才 fsync。</p></li></ul><p>在MySQL中系统默认的设置是 sync_binlog &#x3D; 0，也就是不做任何强制性的磁盘刷新指令，这时候的性能是最好的，但是风险也是最大的。因为一旦主机发生异常重启，在 binlog cache 中的所有 binlog 日志都会被丢失。</p><p>而当 sync_binlog 设置为 1 的时候，是最安全但是性能损耗最大的设置。因为当设置为1的时候，即使主机发生异常重启，也最多丢失 binlog cache 中未完成的一个事务，对实际数据没有任何实质性影响，就是对写入性能影响太大。</p><p>如果能容少量事务的 binlog 日志丢失的风险，为了提高写入的性能，一般会 sync_binlog 设置为 100~1000 中的某个数值。</p><h1 id="如果redo-log与binlog两份日志之间的逻辑不一致，会出现什么问题？"><a href="#如果redo-log与binlog两份日志之间的逻辑不一致，会出现什么问题？" class="headerlink" title="如果redo log与binlog两份日志之间的逻辑不一致，会出现什么问题？"></a>如果redo log与binlog两份日志之间的逻辑不一致，会出现什么问题？</h1><p><code>redo log</code>（重做日志）让<code>InnoDB</code>存储引擎拥有了崩溃恢复能力。</p><p><code>binlog</code>（归档日志）保证了<code>MySQL</code>集群架构的数据一致性。</p><p>虽然它们都属于持久化的保证，但是侧重点不同。</p><p>在执行更新语句过程，会记录<code>redo log</code>与<code>binlog</code>两块日志，以基本的事务为单位，<code>redo log</code>在事务执行过程中可以不断写入，而<code>binlog</code>只有在提交事务时才写入，所以<code>redo log</code>与<code>binlog</code>的写入时机不一样。</p><ul><li><strong>如果在将 redo log 刷入到磁盘之后， MySQL 突然宕机了，而 binlog 还没有来得及写入</strong>。MySQL 重启后，通过 redo log 能将 Buffer Pool 中 id &#x3D; 1 这行数据的 name 字段恢复到新值 xiaolin，但是 binlog 里面没有记录这条更新语句，在主从架构中，binlog 会被复制到从库，由于 binlog 丢失了这条更新语句，从库的这一行 name 字段是旧值 jay，与主库的值不一致性；</li><li><strong>如果在将 binlog 刷入到磁盘之后， MySQL 突然宕机了，而 redo log 还没有来得及写入</strong>。由于 redo log 还没写，崩溃恢复以后这个事务无效，所以 id &#x3D; 1 这行数据的 name 字段还是旧值 jay，而 binlog 里面记录了这条更新语句，在主从架构中，binlog 会被复制到从库，从库执行了这条更新语句，那么这一行 name 字段是新值 xiaolin，与主库的值不一致性；</li></ul><h1 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h1><p><strong>MySQL 为了避免出现两份日志之间的逻辑不一致的问题，使用了「两阶段提交」来解决</strong>，两阶段提交其实是分布式事务一致性协议，它可以保证多个逻辑操作要不全部成功，要不全部失败，不会出现半成功的状态。</p><p> 将<code>redo log</code>的写入拆成了两个步骤<code>prepare</code>和<code>commit</code>，这就是<strong>两阶段提交</strong>。 </p><p>在事务进行的时候写<code>redo log</code>，并且标记为prepare，在事务操作完成后，写入<code>bin log</code>，并将<code>redo log</code>标记为commit，至此完整的事务就完成了。</p><p> 使用<strong>两阶段提交</strong>后，写入<code>binlog</code>时发生异常也不会有影响，因为<code>MySQL</code>根据<code>redo log</code>日志恢复数据时，发现<code>redo log</code>还处于<code>prepare</code>阶段，并且没有对应<code>binlog</code>日志，就会回滚该事务。 </p><p>如果在<code>bin log</code>写完后宕机了，<code>redo log</code>还是prepare状态，那么会认为事务已经完成，根据<code>bin log</code>来恢复数据。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>僵尸进程与孤儿进程</title>
    <link href="/2022/05/07/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/"/>
    <url>/2022/05/07/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是僵尸进程和孤儿进程："><a href="#什么是僵尸进程和孤儿进程：" class="headerlink" title="什么是僵尸进程和孤儿进程："></a>什么是僵尸进程和孤儿进程：</h1><p>​        在 Unix&#x2F;Linux 系统中，正常情况下，子进程是通过父进程创建的，且两者的运行是相互独立的，父进程永远无法预测子进程到底什么时候结束。当一个进程调用 exit 命令结束自己的生命时，其实它并没有真正的被销毁，内核只是释放了该进程的所有资源，包括打开的文件、占用的内存等，但是留下一个称为僵尸进程的数据结构，这个结构保留了一定的信息（包括进程号 the process ID，退出状态，运行时间），这些信息直到父进程通过 wait()&#x2F;waitpid() 来取时才释放。这样设计的目的主要是保证只要父进程想知道子进程结束时的状态信息，就可以得到</p><p>僵尸进程：一个进程使用 fork 创建子进程，如果子进程退出，而父进程并没有调用 wait 或 waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵死进程。</p><p>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被 init 进程(进程号为1)所收养，并由 init 进程对它们完成状态收集工作。</p><h1 id="僵尸进程与孤儿进程的危害："><a href="#僵尸进程与孤儿进程的危害：" class="headerlink" title="僵尸进程与孤儿进程的危害："></a>僵尸进程与孤儿进程的危害：</h1><p>​        僵尸进程虽然不占有任何内存空间，但如果父进程不调用 wait() &#x2F; waitpid() 的话，那么保留的信息就不会释放，其进程号就会一直被占用，而系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害。</p><p>​孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了 init 进程身上，init 进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init，而 init 进程会循环地 wait() 它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init 进程就会出面处理它的一切善后工作。因此孤儿进程并不会有什么危害。</p><p>​如果子进程在 exit() 之后，父进程没有来得及处理，这时用 ps 命令就能看到子进程的状态是“Z”。如果父进程能及时处理，可能用 ps 命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。 如果父进程在子进程结束之前退出，则子进程将由 init 接管。init 将会以父进程的身份对僵尸状态的子进程进行处理。</p><h1 id="如何解决僵尸进程造成的问题："><a href="#如何解决僵尸进程造成的问题：" class="headerlink" title="如何解决僵尸进程造成的问题："></a>如何解决僵尸进程造成的问题：</h1><p>（1）方案一：父进程通过 wait 和 waitpid 等函数等待子进程结束，但这会导致父进程挂起，所以这并不是一个好办法，父进程如果不能和子进程并发执行的话，那我们创建子进程的意义就没有。同时一个 wait 只能解决一个子进程，如果有多个子进程就要用到多个 wait</p><p>（2）方案二：通过信号机制：</p><p>​子进程退出时，向父进程发送 SIGCHILD 信号，父进程处理 SIGCHILD 信号，在信号处理函数中调用 wait 进行处理僵尸进程。</p><p>（3）方案三：fork两次：</p><p>​原理是将进程成为孤儿进程，从而其的父进程变为 init 进程，通过 init 进程处理僵尸进程。具体操作为：父进程一次 fork() 后产生一个子进程随后立即执行 wait(NULL) 来等待子进程结束，然后子进程 fork() 后产生孙子进程随后立即exit(0)。这样子进程顺利终止（父进程仅仅给子进程收尸，并不需要子进程的返回值），然后父进程继续执行。这时的孙子进程由于失去了它的父进程（即是父进程的子进程），将被转交给Init进程托管。于是父进程与孙子进程无继承关系了，它们的父进程均为Init，Init进程在其子进程结束时会自动收尸，这样也就不会产生僵死进程了</p><p>（4）方案四：kill 父进程：</p><p>​严格地来说，僵死进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的那个父进程。因此，当我们寻求如何消灭系统中大量的僵死进程时，答案就是把产生大量僵死进程的那个元凶枪毙掉（也就是通过 kill 发送 SIGTERM 或者 SIGKILL 信号啦）。枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进 程，这些孤儿进程会被 init 进程接管，init 进程会 wait() 这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经僵死的孤儿进程就能瞑目而去了。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka</title>
    <link href="/2022/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kafka/"/>
    <url>/2022/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kafka/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么要用消息队列"><a href="#为什么要用消息队列" class="headerlink" title="为什么要用消息队列"></a>为什么要用消息队列</h1><h2 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h2><p>如果服务调用链路过长，会导致用户等待时间过长，这时一些不需要及时完成的操作，就可以进行异步处理，减少用户等待时间。</p><p>比如一个抽奖项目，有参与<strong>抽奖–中奖–发奖</strong>这三个流程，可以中奖后直接返回中奖结果给用户，然后向消息队列发送消息，发奖的服务再去消息队列中取对应的消息，完成发奖操作。</p><h2 id="削峰填谷"><a href="#削峰填谷" class="headerlink" title="削峰填谷"></a>削峰填谷</h2><p>在类似秒杀活动中,为了避免流量一下子打到服务端，可以前置一个消息队列当作缓冲，服务端尽最大努力取消息队列消费消息，一些超时的请求可以直接返回错误。</p><h2 id="服务解耦"><a href="#服务解耦" class="headerlink" title="服务解耦"></a>服务解耦</h2><p>在商城项目中，用户下订单后，后端会根据生成的订单进行一系列操作，比如：vip等级变更，加积分等，如果这时候公司又要加一些其他服务，那么可能会影响到订单服务。这时候可以加一个发布-订阅模式的消息队列，订单服务生成订单后直接丢到消息队列里，其他下游服务需要订单信息的话再从消息队列中取就行了。</p><h1 id="消息队列会带来哪些问题，如何解决"><a href="#消息队列会带来哪些问题，如何解决" class="headerlink" title="消息队列会带来哪些问题，如何解决"></a>消息队列会带来哪些问题，如何解决</h1><h2 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h2><p>Kafka中的多副本机制允许Partition拥有多个副本，多个副本间数据一致，正常情况下Producer和Consumer都和Leader进行交互。当一个Broker挂掉并且Leader就在这个Broker中，可以在剩余副本中重新选举Leader，来保证高可用性和安全性。</p><blockquote><p>为什么只能和leader交互？ 如果可以随意读写每个follower，就要考虑数据的一致性，会增加系统复杂度，降低容错性。</p></blockquote><h2 id="消息顺序"><a href="#消息顺序" class="headerlink" title="消息顺序"></a>消息顺序</h2><p>在一些业务中需要保证消息被消费的顺序，在Producer生产消息的时候可以把这些消息指定相同的key，这样它们都会进入同一个Partition，这样就保证了有序性。</p><h2 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h2><blockquote><p>消息丢失可以从以下三个方面考虑：</p></blockquote><h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><blockquote><p>生产者发送的消息因为网络原因并没有到达Broker导致消息丢失</p></blockquote><p>在调用send()函数发送完消息后，为了确保消息到达Broker，可以添加回调函数知道Broker时候接收到。另外可以把<strong>retries</strong>参数设置成&gt;3，可以实现自动重发消息。</p><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><blockquote><p>消费者接收消息后，自动提交offset，这时候消费者宕机了，就会导致消息丢失</p></blockquote><p>关闭自动提交offset，等处理完业务后，再手动提交。但是如果业务完成后宕机了，没有提交成功，当再次开始处理消息的时候，就会导致重复消费的问题。</p><h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><blockquote><p>如果一个leader挂掉了，这时候数据还没来得及同步到副本中，信息就丢失了。</p></blockquote><p>可以设置 ：</p><ul><li><p>acks &#x3D; all</p><p>所有副本都<strong>接收</strong>消息后，才算发送成功</p></li><li><p>replication.factor &gt;&#x3D; 3</p><p>副本数量大于3</p></li><li><p>min.insync.replicas &gt; 1</p><p>消息至少被<strong>写入</strong>两个副本才算发送成功</p></li><li><p>unclean.leader.election.enable &#x3D; false</p><p>leader故障后只从和leader完全同步的副本中选举新leader</p></li></ul><h2 id="消息重复"><a href="#消息重复" class="headerlink" title="消息重复"></a>消息重复</h2><blockquote><p>Consumer消费完消息后，还没提交就挂了</p></blockquote><p>设计全局ID，做幂等性校验。</p><h2 id="消息堆积"><a href="#消息堆积" class="headerlink" title="消息堆积"></a>消息堆积</h2><ul><li>看能否提高服务端处理消息都速度，比如多次数据库插入，优化成批量插入</li><li>扩容，增加topic队列和消费者数量，<strong>（一个队列只会分配给一个消费者）</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在阿里云服务器上部署docker</title>
    <link href="/2022/05/04/%E5%9C%A8%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2docker/"/>
    <url>/2022/05/04/%E5%9C%A8%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2docker/</url>
    
    <content type="html"><![CDATA[<h1 id="在阿里云上部署docker"><a href="#在阿里云上部署docker" class="headerlink" title="在阿里云上部署docker"></a>在阿里云上部署docker</h1><h2 id="1-系统版本要求"><a href="#1-系统版本要求" class="headerlink" title="1. 系统版本要求"></a>1. 系统版本要求</h2><ul><li><p>服务器版本<strong>CentOS 8.x</strong> </p></li><li><p>服务器必须是 <strong>x86 64位</strong>系统</p></li><li><p>查看系统的内核版本</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">[root@iZ8vbd7wo3mhy6gadb8egyZ ~]# uname -r<br>4.18.0-348.7.1.el8_5.x86_64<br></code></pre></td></tr></table></figure></li><li><p>将yum更新到最新版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@iZ8vbd7wo3mhy6gadb8egyZ ~]# sudo yum update<br>Last metadata expiration check: 1:22:43 ago on Wed 04 May 2022 03:01:02 PM CST.<br>Dependencies resolved.<br>Nothing to do.<br>Complete!<br></code></pre></td></tr></table></figure></li></ul><h2 id="2-安装Docker"><a href="#2-安装Docker" class="headerlink" title="2. 安装Docker"></a>2. 安装Docker</h2><h3 id="1-安装依赖包"><a href="#1-安装依赖包" class="headerlink" title="1. 安装依赖包"></a>1. 安装依赖包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@iZ8vbd7wo3mhy6gadb8egyZ ~]# sudo yum install -y yum-utils device-mapper-persistent-data lvm2<br></code></pre></td></tr></table></figure><p><em>本人因为已经安装过，就不展示对应的内容了，一般来说看到Complete就代表完成了。</em></p><h3 id="2-添加yum仓库"><a href="#2-添加yum仓库" class="headerlink" title="2. 添加yum仓库"></a>2. 添加yum仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@iZ8vbd7wo3mhy6gadb8egyZ ~]# sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure><h3 id="3-安装Docker"><a href="#3-安装Docker" class="headerlink" title="3. 安装Docker"></a>3. 安装Docker</h3><h4 id="3-1-默认安装最新版"><a href="#3-1-默认安装最新版" class="headerlink" title="3.1 默认安装最新版"></a>3.1 默认安装最新版</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@iZ8vbd7wo3mhy6gadb8egyZ ~]# sudo yum install docker-ce<br></code></pre></td></tr></table></figure><h4 id="3-2-安装指定版本"><a href="#3-2-安装指定版本" class="headerlink" title="3.2 安装指定版本"></a>3.2 安装指定版本</h4><p>查看仓库中的Docker版本并安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@iZ8vbd7wo3mhy6gadb8egyZ ~]# yum list docker-ce --showduplicates | sort -r<br>Last metadata expiration check: 1:31:35 ago on Wed 04 May 2022 03:01:02 PM CST.<br>Installed Packages<br>docker-ce.x86_64               3:20.10.9-3.el8                 docker-ce-stable <br>docker-ce.x86_64               3:20.10.8-3.el8                 docker-ce-stable <br>docker-ce.x86_64               3:20.10.7-3.el8                 docker-ce-stable <br>docker-ce.x86_64               3:20.10.6-3.el8                 docker-ce-stable <br>docker-ce.x86_64               3:20.10.5-3.el8                 docker-ce-stable <br>docker-ce.x86_64               3:20.10.4-3.el8                 docker-ce-stable <br>docker-ce.x86_64               3:20.10.3-3.el8                 docker-ce-stable <br>docker-ce.x86_64               3:20.10.2-3.el8                 docker-ce-stable <br>docker-ce.x86_64               3:20.10.14-3.el8                docker-ce-stable <br>docker-ce.x86_64               3:20.10.14-3.el8                @docker-ce-stable<br>docker-ce.x86_64               3:20.10.1-3.el8                 docker-ce-stable <br>docker-ce.x86_64               3:20.10.13-3.el8                docker-ce-stable <br>docker-ce.x86_64               3:20.10.12-3.el8                docker-ce-stable <br>docker-ce.x86_64               3:20.10.11-3.el8                docker-ce-stable <br>docker-ce.x86_64               3:20.10.10-3.el8                docker-ce-stable <br>docker-ce.x86_64               3:20.10.0-3.el8                 docker-ce-stable <br>docker-ce.x86_64               3:19.03.15-3.el8                docker-ce-stable <br>docker-ce.x86_64               3:19.03.14-3.el8                docker-ce-stable <br>docker-ce.x86_64               3:19.03.13-3.el8                docker-ce-stable <br>Available Packages<br><br>[root@iZ8vbd7wo3mhy6gadb8egyZ ~]# sudo yum install docker-ce-20.10.11.ce<br></code></pre></td></tr></table></figure><h3 id="4-启动Docker并添加开机启动"><a href="#4-启动Docker并添加开机启动" class="headerlink" title="4. 启动Docker并添加开机启动"></a>4. 启动Docker并添加开机启动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@iZ8vbd7wo3mhy6gadb8egyZ ~]# sudo systemctl start docker<br>[root@iZ8vbd7wo3mhy6gadb8egyZ ~]# systemctl enable docker<br></code></pre></td></tr></table></figure><h2 id="2-Docker可视化界面安装"><a href="#2-Docker可视化界面安装" class="headerlink" title="2. Docker可视化界面安装"></a>2. Docker可视化界面安装</h2><h3 id="1-Portainer汉化包的下载与上传"><a href="#1-Portainer汉化包的下载与上传" class="headerlink" title="1. Portainer汉化包的下载与上传"></a>1. Portainer汉化包的下载与上传</h3><h4 id="1-下载"><a href="#1-下载" class="headerlink" title="1. 下载"></a>1. 下载</h4><p>链接：<a href="https://pan.baidu.com/s/1hVvP5msL6LObDAt-v-S-sw?pwd=rj5h">https://pan.baidu.com/s/1hVvP5msL6LObDAt-v-S-sw?pwd=rj5h</a><br>提取码：rj5h</p><h4 id="2-上传"><a href="#2-上传" class="headerlink" title="2. 上传"></a>2. 上传</h4><p>创建目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@iZ8vbd7wo3mhy6gadb8egyZ ~]# mkdir -p /data/portainer/data /data/portainer/public<br></code></pre></td></tr></table></figure><p>将Portainer-CN中的文件上传到data&#x2F;portainer&#x2F;public目录下</p><h3 id="2-拉取Portainer"><a href="#2-拉取Portainer" class="headerlink" title="2. 拉取Portainer"></a>2. 拉取Portainer</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@iZ8vbd7wo3mhy6gadb8egyZ ~]# docker pull portainer/portainer<br></code></pre></td></tr></table></figure><h3 id="3-启动Portainer"><a href="#3-启动Portainer" class="headerlink" title="3. 启动Portainer"></a>3. 启动Portainer</h3><p>需要开启9000端口，可以在服务器安全组中开启。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@iZ8vbd7wo3mhy6gadb8egyZ ~]# docker run -d --restart=always --name portainer -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v /data/portainer/data:/data -v /data/portainer/public:/public portainer/portainer<br></code></pre></td></tr></table></figure><h2 id="4-访问Portainer"><a href="#4-访问Portainer" class="headerlink" title="4. 访问Portainer"></a>4. 访问Portainer</h2><p>在<strong>http:&#x2F;&#x2F;服务器公网ip:9000</strong> 访问</p>]]></content>
    
    
    <categories>
      
      <category>环境部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>环境部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
